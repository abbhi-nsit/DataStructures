book source code
https://github.com/swilliams11/javawebservices_uar

=======================Chapter 1=======================

JSON - javascript object notation
SOA
DOA

JAX-WS api

HttpServlet is well designed for REST style.
	doGet, doPost, doPut, doDelete
	support for MIME types
	access to http headers and bodies
	
JAX-RS
	Another api for REST services
	@GET, @POST annotations
	@PATH annotations for resource
	Easy to send json or xml responses
	A layer over HttpServlet
	
Restlet
	Similar to JAX-RS
	uses annotations
	
JAX-WS
	xml centric API
	@WebService
	@WebServiceProvider
	Generaly used for SOAP applications
	
Separation of concerns
Making a web service is one concern
publishing it is another concern

Web Service
	is a distributed software system whose components can be deployed and executed on physically distinct devices
	
Conversational Patterns :
(1) Request/Response -> client sends request to server, server sends response to client
(2) Solicit/Response -> server sends message to client, then client sends messsage to server
(3) One way	-> A message from client to server with no response
(4) Notification -> A message from server to client with no response

------------------------------------------------------
SOAP - Simple Object Access Protocol
REST - Representational State Transfer


Soap vs Rest

(1)Rest is based on http protocol (get,put,post,delete) , treating everything as a resource.
whereas SOAP is transport neutral. It can support HTTP, SMTP, UDP, TCP protocols.

(2)Soap works only with xml , Rest works with json/xml both.

(3)rest may/may not provide schema definition while sending messages.
It is an architectural style which has no official standard to make messages.
Soap will always provide schema definitions. 
Soap follows set of predefined rules to make SOAP messages.
It will be easy to understand request/response schema and
 their data type constraints when viewing schema information via WSDL by any client.
 
(4)Soap provides default error handling via faults.
We can also create our own custom faults.
In Rest we need to handle all error messages explicitly.

(5)The step of wsdl creation makes it difficult to make any changes in your 
schema classes while implementing in soap.
Rest implementation is quite easy, we just need to make changes in pojo classes.

(6)Soap provides SoapHandler to intercept request both at client/server side 
with both request/response.
we can use filters of j2ee or interceptors of Spring to intercept calls.

(7)Soap is fixed defined set of protocol, whereas rest is architectural style.
While implementing REST, developers can follow any rule,
 for example 
not using http protocol in well defined way.
While in Soap message part is defined as envelope.

one envelope = header + body + fault + attachment

--------------------------------------------------------

SOA -> Service Oriented Architecture

(1)Services should be loosly coupled
	S1 and S2 services should not be dependent on each other
	Any changes to one should not effect another
	
(2) Stateless function call 
	returned value by service should only depend on arguments passed to service
	
Marshelling => memory object -> some document
	java object -> xml/json
	

	
=>REST

It works on HTTP protocol
Http methods like Get, Post, Put, Delete 
MIME type like text/html
Response status code
	200 success
	404 resource not found
	303 redirect
	500 Internal server error
	401 Authentication error
	405 method not supported
Every object in REST is treated as Resource

->Http verb		Operation  Idempotent	Has-Body

POST 			Create		No			Yes
GET				Read		Yes			No
PUT				Update		Yes			Yes
Delete			Delete		Yes			No

GET request has no body.All data in GET is sent via headers.
POST request always has a body, which may be empty.

Accept : 
header information which is sent in Request object.
It specifies the MIME a client can handle.

Content-Type :
MIME type that server sends while sending reponse.
This header also includes charset.
charset specifies character encoding.
eg: Ascii, ANSI, UTF-8

Rest url example :

https://www.amazon.in/index.html

	https://www.amazon.in  => host

	index.html  => url/path/resource


=======================Chapter 2=======================

Difference b/w PUT and POST :
PUT 
(1) creating/overriding a resource/file with specified URI.
(2) PUT to a URI , effects only that URI.
(3) Idempotent
(4) PUT always requires an Id , to be updated in URI

POST 
(1) It will make an action at server which makes
	-> effect one or more than one resource
	-> Gateway to some other protocol
(2) A post to a URI could have any effect at all.
(3) Non-Idempotent
(4) If POST do not contain any id, then a new resource with new id is created.

NOTE : Containers like tomcat/jetty do not have request.getParameter() for PUT.


=>HttpServlet example

//GET  -> id is in header
//POST -> id is in body
String param = request.getParameter("id");

// If the HTTP Accept header is set to application/json OR text/x-json
String accept = request.getHeader("accept");
if(accept.contains("json")) {
} 



---------------------------------------------------------------------------


=> JAX-RS (Java API for XML-RESTful Services)

It is an API.
Its implementation includes
->Jersey
->RESTEasy
->Apache Wink
->Apache CXF


Example 1 :

@ApplicationPath("/resourcesA")
public class RestfulAdage extends Application {
	@Override
	public Set<Class<?>> getClasses() {
		Set<Class<?>> set = new HashSet<Class<?>>();
		set.add(Adages.class);
		return set;
	}
}

curl http://localhost:8080/adages/resourcesA/ 
war file deployed in tomcat has name : adages.war


@XmlRootElement(name = "adage")
public class Adage {

	@XmlElement(required = true)
	private String words;
	
	private int wordCount;
	
	public Adage() {}
	
	@Override
	public String toString() {
		return words + " -- " + wordCount + " words";
	}
	public void setWords(String words) {
		this.words = words;
		this.wordCount = words.trim().split("\\s+").length;
	}
	public String getWords() {
		return this.words;
	}
	public void setWordCount(int wordCount) {
	}
	public int getWordCount() {
		return this.wordCount;
	}
}


=> web.xml

<?xml version="1.0" encoding="UTF-8"?>
<web-app>
	<servlet>
		<servlet-name>jersey</servlet-name>
		<servlet-class>
			com.sun.jersey.spi.container.servlet.ServletContainer
		</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>
</web-app>


**ServletContainer class scans all ApplicationPath annotations and all Path annotations in war file.


@Path("/")
public class Adages { // Add aphorisms to taste... 

	private String[ ] aphorisms = {"What can be shown cannot be said.", 
						"If a lion could talk, we could not understand him.",
						"Philosophy is a battle against the bewitchment of ",
						"Ambition is the death of thought.",
						"The limits of my language mean the limits of my world."
						};

	public Adages() { }

	@GET
	@Produces({ MediaType.APPLICATION_XML }) // could use "application/xml"
	public JAXBElement<Adage> getXml() {
		return toXml(createAdage());
	}

	@GET
	@Produces({ MediaType.APPLICATION_JSON })
	@Path("/json")
	public String getJson() {
		return toJson(createAdage());
	}

	@GET
	@Produces({ MediaType.TEXT_PLAIN })
	@Path("/plain")
	public String getPlain() {
		return createAdage().toString() + "\n";
	}

	private Adage createAdage() {
		Adage adage = new Adage();
		adage.setWords(aphorisms[new Random().nextInt(aphorisms.length)]);
		return adage;
	}

	// Java Adage --> XML document
	@XmlElementDecl(namespace = "http://aphorism.adage", name = "adage")
	private JAXBElement<Adage> toXml(Adage adage) {
		return new JAXBElement<Adage>(new QName("adage"), Adage.class, adage);
	}

	// Java Adage --> JSON document
	// Jersey provides automatic conversion to JSON using the Jackson
	// libraries. In this example, the conversion is done manually
	// with the Jackson libraries just to indicate how straightforward it is.
	private String toJson(Adage adage) {
		String json = "If you see this, there's a problem.";
		try {
			json = new ObjectMapper().writeValueAsString(adage);
		} catch (Exception e) {
		}
		return json;
	}
}


http://localhost:8080/adages/resourcesA/ 
http://localhost:8080/adages/resourcesA/json
http://localhost:8080/adages/resourcesA/plain


---------------------------------------------------------------------------

Example 2 :

import javax.xml.bind.annotation.XmlRootElement; 
import javax.xml.bind.annotation.XmlElement;

@XmlRootElement(name = "prediction")
public class Prediction implements Comparable<Prediction> {
	private String who; // person
	private String what; // his/her prediction
	private int id; // identifier used as lookup key

	public Prediction() {
	}

	@Override
	public String toString() {
		return String.format("%2d: ", id) + who + " ==> " + what + "\n";
	}

	public void setWho(String who) {
		this.who = who;
	}

	@XmlElement
	public String getWho() {
		return this.who;
	}

	public void setWhat(String what) {
		this.what = what;
	}

	@XmlElement
	public String getWhat() {
		return this.what;
	}

	public void setId(int id) {
		this.id = id;
	}

	@XmlElement
	public int getId() {
		return this.id;
	}

	public int compareTo(Prediction other) {
		return this.id - other.id;
	}
}




import java.util.List; 
import java.util.concurrent.CopyOnWriteArrayList; 
import java.util.concurrent.atomic.AtomicInteger; 
import javax.xml.bind.annotation.XmlElement; 
import javax.xml.bind.annotation.XmlElementWrapper; 
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement(name = "predictionsList")
public class PredictionsList {
	private List<Prediction> preds;
	private AtomicInteger predId;

	public PredictionsList() {
		preds = new CopyOnWriteArrayList<Prediction>();
		predId = new AtomicInteger();
	}

	@XmlElement
	@XmlElementWrapper(name = "predictions")
	public List<Prediction> getPredictions() {
		return this.preds;
	}

	public void setPredictions(List<Prediction> preds) {
		this.preds = preds;
	}

	@Override
	public String toString() {
		String s = "";
		for (Prediction p : preds)
			s += p.toString();
		return s;
	}

	public Prediction find(int id) {
		Prediction pred = null;
		for (Prediction p : preds) {
			if (p.getId() == id) {
				pred = p;
				break;
			}
		}
		return pred;
	}

	public int add(String who, String what) {
		int id = predId.incrementAndGet();
		Prediction p = new Prediction();
		p.setWho(who);
		p.setWhat(what);
		p.setId(id);
		preds.add(p);
		return id;
	}
}





import java.io.InputStream; 
import java.io.BufferedReader; 
import java.io.InputStreamReader; 
import javax.ws.rs.GET; 
import javax.ws.rs.POST; 
import javax.ws.rs.PUT; 
import javax.ws.rs.DELETE; 
import javax.ws.rs.Path; 
import javax.ws.rs.PathParam; 
import javax.ws.rs.FormParam; 
import javax.ws.rs.Produces; 
import javax.ws.rs.core.MediaType; 
import javax.ws.rs.core.Context; 
import javax.ws.rs.core.Response; 
import javax.ws.rs.core.Context; 
import javax.servlet.ServletContext; 
import com.fasterxml.jackson.databind.ObjectMapper;

@Path("/")
public class PredictionsRS {
    @Context 
    private ServletContext sctx;          // dependency injection
    private static PredictionsList plist; // set in populate()

    public PredictionsRS() { }

    @GET
    @Path("/xml")
    @Produces({MediaType.APPLICATION_XML}) 
    public Response getXml() {
		checkContext();
		return Response.ok(plist, "application/xml").build();
    }

    @GET
    @Path("/xml/{id: \\d+}")
    @Produces({MediaType.APPLICATION_XML}) // could use "application/xml" instead
    public Response getXml(@PathParam("id") int id) {
		checkContext();
		return toRequestedType(id, "application/xml");
    }

    @GET
    @Produces({MediaType.APPLICATION_JSON})
    @Path("/json")
    public Response getJson() {
		checkContext();
		return Response.ok(toJson(plist), "application/json").build();
    }

    @GET    
    @Produces({MediaType.APPLICATION_JSON})
    @Path("/json/{id: \\d+}")
    public Response getJson(@PathParam("id") int id) {
		checkContext();
		return toRequestedType(id, "application/json");
    }

    @GET
    @Path("/plain")
    @Produces({MediaType.TEXT_PLAIN}) 
    public String getPlain() {
		checkContext();
		return plist.toString();
    }

    @POST
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/create")
    public Response create(@FormParam("who") String who, 
			   @FormParam("what") String what) {
		checkContext();
		String msg = null;
		// Require both properties to create.
		if (who == null || what == null) {
			msg = "Property 'who' or 'what' is missing.\n";
			return Response.status(Response.Status.BAD_REQUEST).
											   entity(msg).
											   type(MediaType.TEXT_PLAIN).
											   build();
		}	    
		// Otherwise, create the Prediction and add it to the collection.
		int id = addPrediction(who, what);
		msg = "Prediction " + id + " created: (who = " + who + " what = " + what + ").\n";
		return Response.ok(msg, "text/plain").build();
    }

    @PUT
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/update")
    public Response update(@FormParam("id") int id,
			   @FormParam("who") String who, 
			   @FormParam("what") String what) {
		checkContext();

		// Check that sufficient data are present to do an edit.
		String msg = null;
		if (who == null && what == null) 
			msg = "Neither who nor what is given: nothing to edit.\n";

		Prediction p = plist.find(id);
		if (p == null)
			msg = "There is no prediction with ID " + id + "\n";

		if (msg != null)
			return Response.status(Response.Status.BAD_REQUEST).
											   entity(msg).
											   type(MediaType.TEXT_PLAIN).
											   build();
		// Update.
		if (who != null) p.setWho(who);
		if (what != null) p.setWhat(what);
		msg = "Prediction " + id + " has been updated.\n";
		return Response.ok(msg, "text/plain").build();
    }

    @DELETE
    @Produces({MediaType.TEXT_PLAIN})
    @Path("/delete/{id: \\d+}")
    public Response delete(@PathParam("id") int id) {
		checkContext();
		String msg = null;
		Prediction p = plist.find(id);
		if (p == null) {
			msg = "There is no prediction with ID " + id + ". Cannot delete.\n";
			return Response.status(Response.Status.BAD_REQUEST).
											   entity(msg).
											   type(MediaType.TEXT_PLAIN).
											   build();
		}
		plist.getPredictions().remove(p);
		msg = "Prediction " + id + " deleted.\n";

		return Response.ok(msg, "text/plain").build();
    }

    //** utilities
    private void checkContext() {
		if (plist == null) populate();
    }

    private void populate() {
		plist = new PredictionsList();

		String filename = "/WEB-INF/data/predictions.db";
		InputStream in = sctx.getResourceAsStream(filename);
		
		// Read the data into the array of Predictions. 
		if (in != null) {
			try {
			BufferedReader reader = new BufferedReader(new InputStreamReader(in));
			int i = 0;
			String record = null;
			while ((record = reader.readLine()) != null) {
				String[] parts = record.split("!");
				addPrediction(parts[0], parts[1]);
			}
			}
			catch (Exception e) { 
			throw new RuntimeException("I/O failed!"); 
			}
		}
    }

    // Add a new prediction to the list.
    private int addPrediction(String who, String what) {
		int id = plist.add(who, what);
		return id;
    }

    // Prediction --> JSON document
    private String toJson(Prediction prediction) {
		String json = "If you see this, there's a problem.";
		try {
			json = new ObjectMapper().writeValueAsString(prediction);
		}
		catch(Exception e) { }
		return json;
    }

    // PredictionsList --> JSON document
    private String toJson(PredictionsList plist) {
		String json = "If you see this, there's a problem.";
		try {
			json = new ObjectMapper().writeValueAsString(plist);
		}
		catch(Exception e) { }
		return json;
    }

    // Generate an HTTP error response or typed OK response.
    private Response toRequestedType(int id, String type) {
		Prediction pred = plist.find(id);
		if (pred == null) {
			String msg = id + " is a bad ID.\n";
			return Response.status(Response.Status.BAD_REQUEST).
											   entity(msg).
											   type(MediaType.TEXT_PLAIN).
											   build();
		}
		else if (type.contains("json"))
			return Response.ok(toJson(pred), type).build();
		else
			return Response.ok(pred, type).build(); // toXml is automatic
    }
}



---------------------------------------------------------------------------

Annotations used :

->jaxb
javax.xml.bind

	@XmlRootElement
	@XmlElement
	@XmlElementWrapper

	Java Architecture for Xml Binding
	->marshalling java objects to xml (serialize)
	->unmarshalling xml to java objects (deserialize)
	
->jersy (JAX-RS)
javax.ws.rs

	@ApplicationPath
	@Path

	@Produces
	@FormParam
	@PathParam

	@GET
	@POST
	@PUT
	@DELETE


->jackson
com.fasterxml.jackson.databind.ObjectMapper

---------------------------------------------------------------------------

