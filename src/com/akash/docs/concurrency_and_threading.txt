Race condition : when multiple processes/threads access same resource and order of accessing resource matters.
Critical section : code that contains race condition

Thread safe : code that has no critical section

all local primitive variable are stored in thread stack
objects are stored in heap, so they can be shared with multiple threads

http://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood
http://java.dzone.com/articles/painless-introduction-javas-threadlocal-storage

ThreadLocal
WeakRefrences

----------------------------------------------------------------

read-then-modify
check-then-act

intrinsic locks -> every object has its own intrinsic lock

reentrant 
synchronized (1)method , (2)block

race condition
visibility
stale object
long and double in 64 bit environment
volatile

thread confinement
ThreadLocal

Object publication and escape

Immutable objects 

final

combination of immutable and volatile

Two ways to handle concurrency in collection:
(1)throw exception when two threads read/write simultaneously,
this solution is still not thread safe as threads can see stale value.
(2)create new copy of collection while doing any operation, 
as thread will not have any impact on copy.
This might have some performance issues.


NOTE:
we have to apply locking where a shared collection is iterated, to avoid ConcurrentModificationException 
In this example toString() method of HashSet uses iterator
While one thread is iterating over set other thread may add new elements.


====================================
@NotThreadSafe
public class UnsafeSequence {
	private int value;
	/** Returns a unique value. */
	public int getNext() {
		return value++;
	}
}

UnsafeSequence illustrates a common concurrency hazard called a race condition.

@ThreadSafe
public class Sequence {
	@GuardedBy("this") private int value;
	public synchronized int getNext() {
		return value++;
	}
}

Whenever more than one thread accesses a given state variable, and one of them might
write to it, they all must coordinate their access to it using synchronization.

What is thread safety:
No set of operations performed sequentially or concurrently
on instances of a thread-safe class can cause an instance to be in an invalid
state.


A stateless Servlet:

@ThreadSafe
public class StatelessFactorizer implements Servlet {
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		encodeIntoResponse(resp, factors);
	}
}


Atomicity:

@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
	private long count = 0;
	public long getCount() { return count; }
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		++count;
		encodeIntoResponse(resp, factors);
	}
}

thread 1 : get count(0)		---		inc 0 to 1		----	set count(1)
thread 2 : 							get count(0)	----	inc 0 to 1		---		set count(1)
thread 3 : 													get count(1)	---		inc 1 to 2 		---		set count(2)

it is not atomic, which
means that it does not execute as a single, indivisible operation. Instead, it is a
shorthand for a sequence of three discrete operations: fetch the current value, add
one to it, and write the new value back. This is an example of a read-modify-write
operation, in which the resulting state is derived from the previous state.

read-modify-write causes operations to be non-Atomic.

Race Condition :

The most common
type of race condition is check-then-act, where a potentially stale observation is
used to make a decision on what to do next.

Check-then-Act  problem causes Race Condition in multiple threads.

Race condition can be understood as a problem in which 
reaching the desired outcome depends on the relative timing of events.

This type of race condition
is called check-then-act: you observe something to be true (file X doesn’t
exist) and then take action based on that observation (create X); but in fact the
observation could have become invalid between the time you observed it and the
time you acted on it (someone else created X in the meantime), causing a problem
(unexpected exception, overwritten data, file corruption).

Race Condition in Lazy Initialization:

A common idiom that uses check-then-act is lazy initialization.

@NotThreadSafe
public class LazyInitRace {
	private ExpensiveObject instance = null;
	public ExpensiveObject getInstance() {
		if (instance == null)
			instance = new ExpensiveObject();
		return instance;
	}
}

LazyInitRace has race conditions that can undermine its correctness. Say that
threads A and B execute getInstance at the same time. A sees that instance
is null, and instantiates a new ExpensiveObject. B also checks if instance is
null. Whether instance is null at this point depends unpredictably on timing,
including the vagaries of scheduling and how long A takes to instantiate the ExpensiveObject
and set the instance field.

Compound actions:

@ThreadSafe
public class CountingFactorizer implements Servlet {
	private final AtomicLong count = new AtomicLong(0);
	public long getCount() { return count.get(); }
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		count.incrementAndGet();
		encodeIntoResponse(resp, factors);
	}
}


Locking :

@NotThreadSafe
public class UnsafeCachingFactorizer implements Servlet {
	private final AtomicReference<BigInteger> lastNumber
	= new AtomicReference<BigInteger>();
	private final AtomicReference<BigInteger[]> lastFactors
	= new AtomicReference<BigInteger[]>();
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		if (i.equals(lastNumber.get()))
			encodeIntoResponse(resp, lastFactors.get());
		else {
			BigInteger[] factors = factor(i);
			lastNumber.set(i);
			lastFactors.set(factors);
			encodeIntoResponse(resp, factors);
		}
	}
}


The definition of thread safety requires that invariants be preserved regardless
of timing or interleaving of operations in multiple threads. One invariant of UnsafeCachingFactorizer
is that the product of the factors cached in lastFactors
equal the value cached in lastNumber; our servlet is correct only if this invariant
always holds.

An Invariant is a non-changing condition in our program that decides the successful implementation.
here:
last number must be equal multiplication of last factors

Just as AtomicLong is a thread-safe holder class for a long integer, AtomicReference is a threadsafe
holder class for an object reference.



Intrinsic Lock :

A synchronized
block has two parts: a reference to an object that will serve as the lock, and a
block of code to be guarded by that lock. A synchronized method is a shorthand
for a synchronized block that spans an entire method body, and whose lock is
the object on which the method is being invoked. (Static synchronized methods
use the Class object for the lock.)
synchronized (lock) {
// Access or modify shared state guarded by lock
}
Every Java object can implicitly act as a lock for purposes of synchronization;
these built-in locks are called intrinsic locks or monitor locks. The lock is automatically
acquired by the executing thread before entering a synchronized block
and automatically released when control exits the synchronized block, whether
by the normal control path or by throwing an exception out of the block.


Intrinsic locks in Java act as mutexes (or mutual exclusion locks), which means
that at most one thread may own the lock.

@ThreadSafe
public class SynchronizedFactorizer implements Servlet {
	@GuardedBy("this") private BigInteger lastNumber;
	@GuardedBy("this") private BigInteger[] lastFactors;
	public synchronized void service(ServletRequest req,ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		if (i.equals(lastNumber))
			encodeIntoResponse(resp, lastFactors);
		else {
			BigInteger[] factors = factor(i);
			lastNumber = i;
			lastFactors = factors;
			encodeIntoResponse(resp, factors);
		}
	}
}

This has poor performance.


Reentrant or Reentrancy :

When a thread requests a lock that is already held by another thread, the requesting
thread blocks. But because intrinsic locks are reentrant, if a thread tries
to acquire a lock that it already holds, the request succeeds. Reentrancy means
that locks are acquired on a per-thread rather than per-invocation basis.
When the count is zero, the lock is considered unheld. When a
thread acquires a previously unheld lock, the JVM records the owner and sets the
acquisition count to one. If that same thread acquires the lock again, the count
is incremented, and when the owning thread exits the synchronized block, the
count is decremented. When the count reaches zero, the lock is released.


public class Widget {
	public synchronized void doSomething() {
		...
	}
}

public class LoggingWidget extends Widget {
	public synchronized void doSomething() {
		System.out.println(toString() + ": calling doSomething");
		super.doSomething();
	}
}


A common locking convention is to encapsulate all mutable state within an
object and to protect it from concurrent access by synchronizing any code path
that accesses mutable state using the object’s intrinsic lock. This pattern is used
by many thread-safe classes, such as Vector and other synchronized collection
classes.
Not all data needs to be guarded by locks—only mutable data that will be
accessed from multiple threads.


@ThreadSafe
public class CachedFactorizer implements Servlet {
	@GuardedBy("this") private BigInteger lastNumber;
	@GuardedBy("this") private BigInteger[] lastFactors;
	@GuardedBy("this") private long hits;
	@GuardedBy("this") private long cacheHits;
	public synchronized long getHits() { return hits; }
	public synchronized double getCacheHitRatio() {
		return (double) cacheHits / (double) hits;
	}
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = null;
		synchronized (this) {
			++hits;
			if (i.equals(lastNumber)) {
				++cacheHits;
				factors = lastFactors.clone();
			}
		}
		if (factors == null) {
			factors = factor(i);
			synchronized (this) {
				lastNumber = i;
				lastFactors = factors.clone();
			}
		}
		encodeIntoResponse(resp, factors);
	}
}

===================================================================================

=====Chapter 3======

synchronized is not only about atomicity or demarcating “critical sections”. Synchronization also
has another significant, and subtle, aspect: memory visibility. We want not only to
prevent one thread from modifying the state of an object when another is using it,
but also to ensure that when a thread modifies the state of an object, other threads
can actually see the changes that were made.

In order to ensure visibility of memory writes across threads, you must use synchronization.

Visibilty :

public class NoVisibility {
	private static boolean ready;
	private static int number;
	private static class ReaderThread extends Thread {
		public void run() {
			while (!ready)
				Thread.yield();
			System.out.println(number);
		}
	}
	public static void main(String[] args) {
		new ReaderThread().start();
		number = 42;
		ready = true;
	}
}



Stale data can cause serious and confusing failures such as unexpected exceptions,
corrupted data structures, inaccurate computations, and infinite loops.

Synchronizing only the setter would not be sufficient: threads calling get 
 would still be able to see stale values.
 

@NotThreadSafe
public class MutableInteger {
	private int value;
	public int get() { return value; }
	public void set(int value) { this.value = value; }
}


@ThreadSafe
public class SynchronizedInteger {
	@GuardedBy("this") private int value;
	public synchronized int get() { return value; }
	public synchronized void set(int value) { this.value = value; }
}

out-of-thin-air safety :

When a thread reads a variable without synchronization, it may see a stale value,
but at least it sees a value that was actually placed there by some thread rather
than some random value.
This safety guarantee is called out-of-thin-air safety.
Out-of-thin-air safety applies to all variables, with one exception: 
64-bit numeric variables (double and long) that are not declared volatile .
 The Java Memory Model requires fetch and store operations to be atomic,
but for nonvolatile long and double variables, the JVM is permitted to treat a
64-bit read or write as two separate 32-bit operations.


Locking and Visibilty :
Intrinsic locking can be used to guarantee that one thread sees the effects of another in a predictable manner.


Volatile variable :

weaker form of synchronization.

When a field is declared volatile, the compiler and runtime
are put on notice that this variable is shared and that operations on it should not
be reordered with other memory operations. Volatile variables are not cached in
registers or in caches where they are hidden from other processors, so a read of a
volatile variable always returns the most recent write by any thread.

When thread A writes to a volatile variable and subsequently
thread B reads that same variable, the values of all variables that were
visible to A prior to writing to the volatile variable become visible to B after
reading the volatile variable.


variables are copied from main memory to cpu cache and then processed by cpu registers.
If we have more than 1 cpu,
then 2 threads processed by different cpu, have different cpu cache for same variable.



____________			_____________________
|			|			|					|
|	CPU	1	|			|	CPU 1 cache  	|
|_Registers_|			|___________________|

												-------------> Main Memory

____________			_____________________
|			|			|					|
|	CPU	2	|			|	CPU 2 cache  	|
|_Registers_|			|___________________|


When not using volatile variable, we do not know when cpu cache value is written back to main memory.

NOTE :
Making a variable volatile is not enough.
If a variable is read and written by many threads, then we may fall in a race condition.
For example Read-Modify-Write scenario.

To overcome this we have 2 solutions:
(1)Use synchronized keyword
(2)Use AtomicLong or AtomicRefrence  which are classes in java.util.concurrent package


----------

Publishing and escape :

Publishing an object means making it available to code outside of its current scope,
such as by storing a reference to it where other code can find it, returning it
from a nonprivate method, or passing it to a method in another class.


-->storing a refrence in public static field

	public static Set<Secret> knownSecrets;
	public void initialize() {
		knownSecrets = new HashSet<Secret>();
	}
	
	
-->Returning a refrence from a non-private method

	class UnsafeStates {
		private String[] states = new String[] {
			"AK", "AL" ...
		};
		public String[] getStates() { return states; }
	}
	
-->Any fields of a nonprivate refrence are also considered as published

-->overridable methods (neither private nor final)

***IMP
-->publish an inner class instance

Do not allow the this reference to escape during construction.

-->Avoid calling thread.start() method from inside the constructor

https://stackoverflow.com/questions/12467101/how-this-escapes-from-a-published-inner-class/12467202#12467202
http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html


public class ThisEscape {

    public Integer i = 47;

    public ThisEscape(EventSource source) {
            source.registerListener(
                    new EventListener() {
                            ThisEscape outerRef = ThisEscape.this;//added by compiler
                            public void onEvent(Event e) {
                                    doSomething(e);
                            }
                    });
    }
}

public class EventSource {
    public void registerListener(EventListener listener) {
        
    }
}


Problem with this approach is that, you can have a situation where inner class will use your class object
 and your class object is still in construction. Same problem exists with starting thread from constructor.
 
class MyThread implements Runnable {
	
	private Thread thread;
	
	MyThread() {
		thread = new Thread(this);	//creating a thread here and passing this is ok,
		thread.start();				//but never start thread in constructor
	}
	
	public void run() {
		...
	}
}

->Never create inner classes in the constructor, either anonymous, local, static or non-static
->Avoid any transitive combination of the rules above, i.e. 
don't create an anonymous inner class in a private or protected final method that is invoked from within the constructor
->Exposing this reference from constructor :
		->setting this in a static field
		->adding this in a collection
		->publishing this via non-static inner class
		

public class Safe { 

  private Object me;
  private Set set = new HashSet();
  private Thread thread;

  public Safe() { 
    // Safe because "me" is not visible from any other thread
    me = this;

    // Safe because "set" is not visible from any other thread
    set.add(this);

    // Safe because MyThread won't start until construction is complete
    // and the constructor doesn't publish the reference
    thread = new MyThread(this);
  }

  public void start() {
    thread.start();
  }

  private class MyThread(Object o) {
    private Object theObject;

    public MyThread(Object o) { 
      this.theObject = o;
    }

    ...
  }
}

public class Unsafe {
  public static Unsafe anInstance;
  public static Set set = new HashSet();
  private Set mySet = new HashSet();

  public Unsafe() {
    // Unsafe because anInstance is globally visible
    anInstance = this;

    // Unsafe because SomeOtherClass.anInstance is globally visible
    SomeOtherClass.anInstance = this;

    // Unsafe because SomeOtherClass might save the "this" reference
    // where another thread could see it
    SomeOtherClass.registerObject(this);

    // Unsafe because set is globally visible 
    set.add(this);

    // Unsafe because we are publishing a reference to mySet
    mySet.add(this);
    SomeOtherClass.someMethod(mySet);

    // Unsafe because the "this" object will be visible from the new
    // thread before the constructor completes
    thread = new MyThread(this);
    thread.start();
  }

  public Unsafe(Collection c) {
    // Unsafe because "c" may be visible from other threads
    c.add(this);
  }
}


Thread Confinement :

https://www.quora.com/Java-programming-language/What-are-some-tips-tricks-and-gotchas-when-using-ThreadLocal
http://stackoverflow.com/questions/11283369/how-does-threadlocal-usage-reduce-reusability

class Thread {
	ThreadLocal.ThreadLocalMap threadLocals = null;
}

//Every thread has its own map.

class ThreadLocal {

	get() OR set() {
	
		Thread t = Thread.currentThread();
		ThreadLocalMap map = t.threadLocals;
		map.get() OR map.set()
	}
}

It is easy to abuse ThreadLocal by treating its thread confinement property as
a license to use global variables or as a means of creating “hidden” method arguments.
Like global variables, thread-local variables can detract from reusability
and introduce hidden couplings among classes, and should therefore be used
with care.

Immutable Objects :

Immutable objects are always thread-safe.
Their invariants are established by the constructor, 
and if their state cannot be changed, these invariants always hold.

Whenever a group of related data items must
be acted on atomically, consider creating an immutable holder class for them,
such as OneValueCache.

@Immutable
class OneValueCache {
	private final BigInteger lastNumber;
	private final BigInteger[] lastFactors;
	public OneValueCache(BigInteger i,
	BigInteger[] factors) {
		lastNumber = i;
		lastFactors = Arrays.copyOf(factors, factors.length);
	}
	public BigInteger[] getFactors(BigInteger i) {
		if (lastNumber == null || !lastNumber.equals(i))
			return null;
		else
			return Arrays.copyOf(lastFactors, lastFactors.length);
	}
}

@ThreadSafe
public class VolatileCachedFactorizer implements Servlet {
	private volatile OneValueCache cache = new OneValueCache(null, null);
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = cache.getFactors(i);
			if (factors == null) {
				factors = factor(i);
				cache = new OneValueCache(i, factors);
			}
		encodeIntoResponse(resp, factors);
	}
}

Immutable and Affectively immutable classes :

http://stackoverflow.com/questions/16678416/different-between-immutable-and-effectively-immutable-objects

Affectively Immutable class is when class has mutable instance variables but are not published as public.
for eg , having a ArrayList in a class and returning its copy from getter method.
Or having a mutable object with returning its copy from getter.

Truly Immutable class is when all its instance variables are immutable.

properties of Immutable class :
->setting all instance variables in constructor
->removing setters
->passing copy of mutable object from getter method
->making class final
->hashcode of immutable objects must be cashed



====================================================================================================

Spring transactions
Refrences in java

============Chapter 4===========

The design process for a thread-safe class should include these three basic elements:
• Identify the variables that form the object’s state;
• Identify the invariants that constrain the state variables;
• Establish a policy for managing concurrent access to the object’s state.

