Preorder, inorder, postorder using recursion | without using recursion
level order traversal (BFS) -> queue, recursion, 2 stack
get level of a node -> queue, recursion
get all nodes at a level -> queue, recursion
height of a binary tree
check if a binary tree is BST
print left view of binary tree		-- NLR keep tracking depth from the root , iterative | recursive
print right view of binary tree		-- NRL keep tracking depth from the root , iterative | recursive
print top view of binary tree		-- level order traversal, keep track of horizontal dist from root, create a map for (dist_from_root, node)
print bottom view of binary tree	-- same as top view, but next node found for same dist key , will override old key
print binary tree in vertical order
print boundary nodes in binary tree
print diagonal nodes in binary tree
Diagonal sum of binary tree
Kth largest in BST
Inorder traversal of binary tree without recursion with stack
Inorder traversal of binary tree without recursion without stack
Delete binary tree
check if two binary trees are identical
check if two binary trees are isomorphic
check if two trees are mirror
	->recursive
		->node.data, left==right, right==left
	->iterative
		->level order traversal with isLeft varaible
		->compare LNR and RNL
convert a binary tree into its mirror
--sorted linked list to BST
	->O(nlog(n)) mid of linked list will be root, use recursive for left and right
	->O(n) 
sorted array to balanced BST
	->mid of array will be root, use recursive for left and right
BST to min heap
	->inorder traversal of BST is min heap
normal BST to balanced BST
	->inorder of BST, sorted array to balanced BST
find median in BST
	->check no of nodes in BST,do inorder traversal and stop at n/2
BST from preorder
	->first element will be root, find first number in array greater than root,right subtree starts from there.Recursive
BST from postorder
Construct Tree from given Inorder and Preorder traversals
Construct a tree from Inorder and Level order traversals
Construct Tree from given Inorder and Postorder traversals
binary tree to doubly linked list

Lowest Common Ancestor(LCA)
	->findPath(Node,Node,List<Node>)
			recursively find full path of a node in a tree and capture it in a list.
			time = O(n),  memory = O(n) 
	-> do any traversal on tree and store parent of each node in a hashmap 
			time = O(n),  memory = O(n) 
	-> Every node should return a status object of two boolean variables
		every node should tell if its subtree(including itself), contains both nodes
	-> Build Euler path of tree with level of nodes
		find minimum level bw the two nodes

check if binary tree is heap   -> level order traversal, check parent child relation (0 to n/2)
given level order traversal of binary tree, check if min heap

--Construct all possible BSTs for keys 1 to N
--Find all possible binary trees with given Inorder Traversal
--merge k sorted arrays
--check if two nodes are swapped in BST
--Diameter of a binary tree
--floor and ceiling of a BST

--path with max sum in binary tree
--Check if all leaves are at same level
print perfect binary tree in below form:
	1 2 3 4 7 5 6 8 15 9 14 10 13 11 12 16 31 17 30 18 29 19 28 20 27 21 26  22 25 23 24
	http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/
	-> 2 queue and 1 stack
--Remove all nodes which don’t lie in any path with sum>= k
--Convert left-right representation of a binary tree to down-right
Minimum no. of iterations to pass information to all nodes in the tree

Check for Children Sum Property in a Binary Tree 
	
--------------------------------------------------

--binary tree
--BST
--AVL tree
--Segment tree
	https://kartikkukreja.wordpress.com/2014/11/09/a-simple-approach-to-segment-trees/

red black tree
interval tree
threaded binary tree

--Heap

-------------------------------------------------
void preorder(Node root) {
	if(root != null) {
		process(root);
		preorder(root.left);
		preorder(root.right);
	}
}

void inorder(Node root) {
	if(root != null) {
		inorder(root.left);
		process(root);
		inorder(root.right);
	}
}

void postorder(Node root) {
	if(root != null) {
		postorder(root.left);
		postorder(root.right);
		process(root);
	}
}

void preOrder(Node root) {
	Stack<Node> stack = new Stack<>();
	stack.push(root);
	while(stack.size() > 0) {
		Node temp = stack.pop();
		process(temp);
		if(temp.left != null) {
			stack.push(temp.left);
		}
		if(temp.right != null) {
			stack.push(temp.right);
		}
	}
}


void inOrder(Node root) {
	Stack<Node> stack = new Stack<>();
	stack.push(root);
	while(root.left != null) {
		stack.push(root.left);
		root = root.left;
	}
	while(stack.size() > 0) {
		Node temp = stack.pop();
		process(temp);
		if(temp.right != null) {
			temp = temp.right;
			stack.push(temp);
			while(temp.left != null) {
				temp = temp.left;
				stack.push(temp);
			}
		}
	}
}


void postOrder(Node root) {
	Stack<Node> stack = new Stack<>();
	stack.push(root);
	while(root.left != null) {
		stack.push(root.left);
		root = root.left;
	}
	while(stack.size() > 0) {
		Node temp = stack.peek();
		if(temp.isRightNodeProcessed()) {
			process(temp);
			stack.pop();
		} else {
			temp.setRightNodeProcessed(true);
			if(temp.right != null) {
				temp = temp.right;
				stack.push(temp);
				while(temp.left != null) {
					temp = temp.left;
					stack.push(temp);
				}
			}
		}
	}
}


void inOrder(Node root) {
	Node temp = root;
	Node pre = null;
	while(temp != null) {
		if(temp.left != null) {
			pre = temp.left;
			while(pre.right != null && pre.right != temp) {
				pre = pre.right;
			}
			if(pre.right == null) {
				pre.right = temp;
				temp = temp.left;
			} else {
				pre.right = null;
				process(temp);
				temp = temp.right;
			}
		} else {
			process(temp);
			temp = temp.right;
		}
	}
}

------------------------

// recursive way to calculate height of binary tree

int getHeight(Node root) {
	if(root == null) {
		return 0;
	}
	int left = getHeight(root.left);
	int right = getHeight(root.right);
	return max(left, right) + 1;
}

------------------------

// recursive way to calculate height of binary tree

private int height = 0;

public int getHeight(Node root) {
	getHeight(root, 1);
	return height;
}

private void getHeight(Node root, int level) {
	if(root != null) {
		if(height < level) {
			height = level;
		}
		getHeight(root.left, level+1);
		getHeight(root.right, level+1);
	}
}

------------------------

// level order traversal, without calculating level of node
// iterative way of level order traversal

void levelOrderTraversal(Node root) {
	Queue<Node> queue = new LinkedList<>();
	queue.add(root);
	while(queue.size() != 0) {
		Node temp = queue.poll();
		process(temp);
		if(temp.left != null) {
			queue.add(temp.left);
		}
		if(temp.right != null) {
			queue.add(temp.right);
		}
	}
}

------------------------

// level order traversal with calculating each level and height
// iterative way to calculate height

int levelOrderTraversal(Node root) {
	Queue<Node> queue = new LinkedList<>();
	queue.add(root);
	int height = 0;
	while(queue.size() != 0) {
		int size = queue.size();
		height++;
		while(size > 0) {
			size--;
			Node temp = queue.poll();
			process(temp)
			if(temp.left != null) {
				queue.add(temp.left);
			}
			if(temp.right != null) {
				queue.add(temp.right);
			}
		}
	}
	return height;
}


------------------------

// recursive way of level order traversal

void levelOrderTraversal() {
	int height = getHeight(root);
	for(int i=0; i<height; i++) {
		recursiveLevelOrder(root, i);
	}
}

private void recursiveLevelOrder(Node root, int level) {
	if(root != null) {
		if(level == 0) {
			process(root);
		} else {
			recursiveLevelOrder(root.left, level-1);
			recursiveLevelOrder(root.right, level-1);
		}
	}
}

------------------------

//check if binary tree is a BST

private previousNode = null;
boolean isBinaryTreeBst(Node root) {
	if(root != null) {
		if( !isBinaryTreeBst(root.left) ) {
			return false;
		}
		if(previousNode != null && previousNode.value > root.value) {
			return false;
		}
		previousNode = root;
		return isBinaryTreeBst(root.right)
	}
	return true;
}


------------------------

// print left view of binary tree
// recursive way
// N L R

private int levelProcessed = 0;

public void printLeftView(Node root) {
	printLeftView(root, 1);
}

private void printLeftView(Node root, int level) {
	if(root != null) {
		if(levelProcessed < level) {
			levelProcessed++;
			process(root);
		}
		printLeftView(root.left, level + 1);
		printLeftView(root.right, level + 1);
	}
}

------------------------

// print left view of binary tree
// iterative way
// N L R

void printLeftView(Node root) {
	Queue<Node> queue = new LinkedList<>();
	queue.add(root);
	int level = 0;
	int levelProcessed = 0;
	while(queue.size() > 0) {
		level++;
		int size = queue.size();
		while(size > 0) {
			size--;
			Node temp = queue.poll();
			if(levelProcessed < level) {
				levelProcessed++;
				process(temp);
			}
			if(temp.left != null) {
				queue.add(temp.left);
			}
			if(temp.right != null) {
				queue.add(temp.right);
			}
		}
	}
}

------------------------

// print right view of binary tree
// recursive way
// N R L

private int levelProcessed = 0;

public void printRightView(Node root) {
	printRightView(root, 1);
}

private void printRightView(Node root, int level) {
	if(root != null) {
		if(levelProcessed < level) {
			levelProcessed++;
			process(root);
		}
		printRightView(root.right, level + 1);
		printRightView(root.left, level + 1);
	}
}

------------------------

// print right view of binary tree
// iterative way
// N R L

void printRightView(Node root) {
	Queue<Node> queue = new LinkedList<>();
	queue.add(root);
	int level = 0;
	int levelProcessed = 0;
	while(queue.size() > 0) {
		level++;
		int size = queue.size();
		while(size > 0) {
			size--;
			Node temp = queue.poll();
			if(levelProcessed < level) {
				levelProcessed++;
				process(temp);
			}
			if(temp.right != null) {
				queue.add(temp.right);
			}
			if(temp.left != null) {
				queue.add(temp.left);
			}
		}
	}
}

------------------------

// print top view of binary tree
// can also be written in iterative way,
// each node has to store its level

private Map<Integer,Node> map = new TreeMap<>();

void printTopView(Node root) {
	printTopView(root, 0);
	map.values().iterator().forEachRemaining(node -> SOP(node.value));
}

private void printTopView(Node root, int level) {
	if(root != null) {
		if(map.get(level) != null) {
			map.put(level, root);
		}
		printTopView(root.left, level - 1);
		printTopView(root.right, level + 1);
	}
}

------------------------

// print bottom view of binary tree
// can also be written in iterative way,
// each node has to store its level

private Map<Integer,Node> map = new TreeMap<>();

void printBottomView(Node root) {
	printBottomView(root, 0);
	map.values().iterator().forEachRemaining(node -> SOP(node.value));
}

private void printBottomView(Node root, int level) {
	if(root != null) {
		map.put(level, root);
		printBottomView(root.left, level - 1);
		printBottomView(root.right, level + 1);
	}
}

------------------------

// print vertical order sum in binary tree
// can also be written in iterative way,
// each node has to store its level

private Map<Integer,Integer> map = new TreeMap<>();

void printVerticalOrderSum(Node root) {
	printVerticalOrderSum(root, 0);
	map.values().iterator().forEachRemaining(value -> SOP(value));
}

private void printVerticalOrderSum(Node root, int level) {
	if(root != null) {
		Integer value = map.get(level);
		if(value == null) {
			map.put(level, root.value);
		} else {
			map.put(level, value + root.value);
		}
		printVerticalOrderSum(root.left, level - 1);
		printVerticalOrderSum(root.right, level + 1);
	}
}

------------------------

// print boundary nodes in binary tree

void printBoundary(Node root) {
	if(root != null) {
		process(root);
		printLeft(root.left);
		printLeaves(root.left);
		printLeaves(root.right);
		printRight(root.right);
	}
}

void printLeft(Node root) {
	if(root != null) {
		if(root.left != null) {
			process(root);
			printLeft(root.left);
		} else if(root.right != null) {
			process(root);
			printLeft(root.right);
		}
	}
}

void printRight(Node root) {
	if(root.right != null) {
		printRight(root.right);
		process(root);
	} else if(root.left != null) {
		printRight(root.left);
		process(root);
	}
}

void printLeaves(Node root) {
	if(root != null) {
		if(root.left == null && root.right == null) {
			process(root);
			return;
		}
		printLeaves(root.left);
		printLeaves(root.right);
	}
}

------------------------

// check if two binary trees are identical

boolean isIdentical(Node node1, Node node2) {
	if(node1 != null || node2 != null) {
		if(node1 == null) {
			return false;
		}
		if(node2 == null) {
			return false;
		}
		if(node1.data != node2.data) {
			return false;
		}
		if( !isIdentical(node1.left, node2.left)) {
			return false;
		}
		return isIdentical(node1.right, node2.right);
	}
	return true;
}

------------------------

// check if two binary trees are isomorphic

boolean isomorphic(Node node1, Node node2) {
	if(node1 != null || node2 != null) {
		if(node1 == null) {
			return false;
		}
		if(node2 == null) {
			return false;
		}
		if(node1.data != node2.data) {
			return false;
		}
		if( (isomorphic(node1.left, node2.left) && isomorphic(node1.right, node2.right))
			|| 
			(isomorphic(node1.left, node2.right) && isomorphic(node1.right, node2.left)) ){
			return true;
		}
		return false;
	}
	return true;
}

------------------------

// check if two trees are mirror

boolean isMirror(Node node1, Node node2) {
	if(node1 != null || node2 != null) {
		if(node1 == null) {
			return false;
		}
		if(node2 == null) {
			return false;
		}
		if(node1.data != node2.data) {
			return false;
		}
		if( !isMirror(node1.left, node2.right)) {
			return false;
		}
		return isMirror(node1.right, node2.left);
	}
	return true;
}

------------------------

// convert a binary tree into its mirror

Node mirror(Node root) {
	if(root != null) {
		Node left, right;
		right = mirror(root.left);
		left = mirror(root.right);
		root.left = left;
		root.right = right;
		return root;
	}
	return null;
}

------------------------

// sorted array to BST

Node root = sortedArrayToBst(arr, 0, arr.length-1);

Node sortedArrayToBst(int arr[], int start, int end) {
	if(start <= end) {
		int mid = start + (end-start)/2 ;
		Node node = new Node();
		node.data = arr[mid];
		node.left = sortedArrayToBst(arr, start, mid-1);
		node.right = sortedArrayToBst(arr, mid+1, end);
		return node;
	}
	return null;
}

------------------------

// sorted singly linked list to BST

TreeNode sortedLinkedListToBst(LlNode node) {
	if(node != null) {
		LlNode middleNode = getMiddle(node);
		LlNode nextToMiddle = middleNode.next;
		middleNode.next = null;
		TreeNode treeNode = new TreeNode();
		treeNode.data = middleNode.data;
		treeNode.left = sortedLinkedListToBst(node);
		treeNode.right = sortedLinkedListToBst(nextToMiddle);
		return treeNode;
	}
	return null;
}

LlNode getMiddle(LlNode node) {
	LlNode fastPointer = node;
	LlNode slowPointer = node;
	LlNode prevToSlow = null;
	while(fastPointer.next != null && fastPointer.next.next != null) {
		fastPointer = fastPointer.next.next;
		prevToSlow = slowPointer;
		slowPointer = slowPointer.next;
	}
	if(prevToSlow != null) {
		prevToSlow.next = null;
	}
	return slowPointer;
}

------------------------

// Lowest Common Ancestor(LCA)
// recursive findPath()

time 	-- O(N)
memory 	-- O(N)

Node lowestCommonAncestor(Node root, Node node1, Node node2) {
	List<Node> list1 = new ArrayList<>();
	List<Node> list2 = new ArrayList<>();
	findPath(root, node1, list1);
	findPath(root, node2, list2);
	Collections.reverse(list1);
	Collections.reverse(list2);
	if(list1.size() == 0 || list2.size() == 0) {
		return null;
	}
	int minSize = list1.size() > list2.size() ? list2.size() : list1.size();
	return list1.get(minSize);
}

boolean findPath(Node key, Node root, List<Node> list) {
	if(root != null) {
		if(key.data == root.data) {
			list.add(root);
			return true;
		}
		if(findPath(key, root.left, list)) {
			list.add(root);
			return true;
		}
		if(findPath(key, root.right, list)) {
			list.add(root);
			return true;
		}
	}
	return false;
}

------------------------

// Lowest Common Ancestor(LCA)
time 	-- O(N)
memory 	-- O(1)

class Pojo {
	boolean isNode1;
	boolean isNode2;
}

private Node lca = null;

Node findPath(Node root, Node node1, Node node2) {
	findPath(root, node1, node2);
	if(lca != null) {
		print(lca);
	}
}

Pojo findPath(Node root, Node node1, Node node2) {
	Pojo pojo = new Pojo();
	if(root != null) {
		if(root.data == node1.data) {
			pojo.isNode1 = true;
		} else if(root.data == node2.data) {
			pojo.isNode2 = true;
		}
		Pojo leftChildPojo = findPath(root.left, node1, node2);
		if(lca != null) {
			return pojo;
		}
		if( (pojo.isNode1 && leftChildPojo.isNode2) ||
			(pojo.isNode2 && leftChildPojo.isNode1) ) {
			
			lca = root;
			return pojo;
		}
		Pojo rightChildPojo = findPath(root.right, node1, node2);
		if(lca != null) {
			return pojo;
		}
		if( (pojo.isNode1 && rightChildPojo.isNode2) ||
			(pojo.isNode2 && rightChildPojo.isNode1) ) {
			
			lca = root;
			return pojo;
		}
	}
	return pojo;
}


------------------------

// Lowest Common Ancestor(LCA)
// recursive saving parent of each node in hashmap

time 	-- O(N)
memory 	-- O(N)





------------------------

// Lowest Common Ancestor(LCA)
// Euler method

time 	-- O(N)
memory 	-- O(N)




------------------------
