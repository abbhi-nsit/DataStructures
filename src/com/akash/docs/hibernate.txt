interview questions

diff b/w merge and update
diff b/w get and load
diff b/w save and saveOrUpdate
diff b/w save and persist
N+1 problem
diff b/w flush and commit
session and transaction
session and sessionFactory
jdbc driver connection code
jdbc transaction isolation levels
first level cache, second level cache, query cache
transient, managed and detached objects
how to convert managed to detached
how to convert detached to managed
 - diff b/w list and set
 		http://stackoverflow.com/questions/6562673/onetomany-list-vs-set-difference
		http://stackoverflow.com/questions/13812283/difference-between-set-and-bag-in-hibernate
when oneToOne do not work with lazy
 - order and sorted collection
diff b/w getCurrentSession() and openSesion()
cascade with inverse option
 - criteria api
best way to make an hibernate entity
 - types of inheritance in hibernate
JoinTable and JoinColumn
advantages of hibernate over jdbc
NamedEntityGraph

-----------------------------------------------

Hibernate

*** http://www.onjava.com/pub/a/onjava/2006/09/13/dont-let-hibernate-steal-your-identity.html?page=1

<version name="version"  unsaved-value="null" generated="always"  insert="true" />


Methods of Session class

get()
load()

save()
persist()

update()
saveOrUpdate()
merge()

delete()


Methods of EntityManager

find()
persist()
merge()
remove()

(Q)Difference b/w merge() and update() ?
Ans : 
-->update will fire only one sql for update
merge will first fire select (if entity is not loaded) and then update

-->update will throw Exception if identifier not found
merge will add a new row if identifier not found

-->Merge creates a new instance of your entity, copies the state from the supplied entity,
 and makes the new copy managed.
The instance you pass in will not be managed (any changes you make will not be part of the transaction
 unless you call merge again).

-->method signature
public void update(Object object);
public Object merge(Object object);



(Q)Difference b/w get() and load() ?
Ans :
When an entity already exists in DB we should use load()
It first checks in session cache then in DB.
if not found it throws exception
load() will return a proxied object.

Proxy means, hibernate will prepare some fake object with given identifier
 value in the memory without hitting the database.
 database won't be hit until the proxy is first invoked.
A consequence of this is that you may get an ObjectNotFoundException later,
 as soon as you try to access the returned placeholder and force its initialization.

get() can be used to check if entity exists in DB or not.
It returns null if not found

session.get(MyEntity.class, 1L);							//sql query is fired
MyEntity objFromLoad = session.load(MyEntity.class, 1L);	//No sql query is fired
objFromLoad.getName();										//Sql query is fired if object is not is session cache


(Q)What is N+1 problem and how to resolve it ?
Ans :
There may be a scenario where we fetch some objects and their children are fetch after that
As a result , their will be N+1 sql queries.
eg:
	users are loaded 
		Select * from users where age>18
	addresses of all users will be loaded
		select * from address where user_id=123
1 parent object can have N children
1 for the parent and
N for the children

To solve this we can load all entities in single sql as :
SELECT parent LEFT OUTER JOIN child

this query can also be used in HQL as :
FROM parent JOIN FETCH child 

NOTE : we can use this logic whenever we have to load full object graph.
OR we can use @NamedEntityGraph

(Q)Difference b/w save() and persist() ?
persist() method saves entities and their children inside a transaction.
persist() method throws TransactionRequiredException when it is used outside transaction

save() method can be used outside transaction, but then it will not save children entities.

save() with transaction ==== persist()

(Q)saveOrUpdate

It can be used outside transaction.
If used outside transaction then only parent entity saved.

NOTE : save() and saveOrUpdate() if used outside transaction, and you want to save mapped entities,
		you have to use session.flush()
		
Things that save data to DB :
(1)session.flush()
(2)transaction.commit()
(3)fire a DDL command, all queries before DDL command will be committed.
(4)fire HQL select command, all previous queries that include in SELECT HQL are commited.


Object is part of persistent context and tracked for any changes:
save()
saveOrUpdate()
merge()
update()
persist()

?get()

-----------------------------------------

NOTE : One SessionFactory object is created for each Data source.

(Q) Session and Transaction
http://stackoverflow.com/questions/5409085/what-is-the-difference-between-a-session-and-a-transaction-in-jpa-2-0

Connection.java
	void commit()
	void rollback()
	
Session.java
	Transaction beginTransaction();
	
Transaction.java
	void commit()
	void rollback()
	
=>Why hibernate added an extra layer of class(Session and Transaction), while in jdbc it has only one class (Connection) ?

A session contains multiple transaction.
that is multiple transactions for same connection object.
If a Requires_New transaction is opened, then 
previous connection is suspended and new connection is opened.


(Q) JPA vs Hibernate
http://stackoverflow.com/questions/9881611/whats-the-difference-between-jpa-and-hibernate


(Q) jdbc transaction isolation levels ?
0 - Flush
1 - Commit
2 - Repeatable_Read	:  changes done by another tnx in a row, does not effect tnx ran earlier than that.
						Repeated 'select' fires have no impact by other 'update' on same row.
3 - Phantom_Read	:  new row inserted by another tnx get read second time in a tnx.

int TRANSACTION_NONE             = 0;			nothing
int TRANSACTION_READ_UNCOMMITTED = 1;	2^0		only flush
int TRANSACTION_READ_COMMITTED   = 2;	2^1		Commited + Non_Repeatable_read + Phantom
int TRANSACTION_REPEATABLE_READ  = 4;	2^2		Commited + Phantom
int TRANSACTION_SERIALIZABLE     = 8;	2^3		Commited

======================================================


hibernate

http://www.javagyan.com/preparing-for-an-interview/hibernate-interview-questions
http://blog.jhades.org/setup-and-gotchas-of-the-hibernate-second-level-and-query-caches/
https://dzone.com/articles/sorting-collections-hibernate

(Q)get()-load()
(Q)merge()-update()
(Q)session - sessionfactory
(Q)session - transaction

(Q)
transient	: never persisted and not attached to a session
persisted	: attached to a unique session
detached	: previously persisted but not attached to session

(Q) how lazy loading works and why required ?
(Q) What is hibernate proxy and how it works ?

We apply lazy loading on child entity of any parent entity.
When we load parent entity, a proxy object of child entity is returned
proxy object only contains id of an object with all other fields as default/null.
proxy is an instance of HibernateProxy.

class User {
	@OneToMany
	List<Address> addrs
}

user.getAddrs();
//this will return a proxy object without firing any sql query

user.getAddrs().get(0).getCity();
//this will fire sql query and fetch all fields of address entity

=>How to load original hibernate object without proxy:

entity = (T)((HibernateProxy) entity).getHibernateLazyInitializer().getImplementation();



Related entity or collections in (OneToOne,OneToMany,ManyToMany) are not loaded when actual entity is loaded.
These are loaded by calling getters of proxy classes.
calling getter from proxy classes out of session will throw LazyInitializationException.
We can get actual implementation for proxy class.
entity = (T) ((HibernateProxy) entity).getHibernateLazyInitializer().getImplementation();

(Q)sorted and ordered collection

@OrderBy		-- to order list based on DB
@Sort			-- to order list in memory
@OrderColumn	-- to index the ordering

@javax.persistence.OrderBy("startYear, endYear")
@org.hibernate.annotations.Sort(type = SortType.COMPARATOR, comparator = EventCompator)
@org.hibernate.annotations.OrderBy("start_year, nvl(end_year , start_year)")

(Q)conditions while making your own entity class
-private fields , public getter/setter
-override equals() hashcode()
-create no-argument constructor
-do not make class as final,because hibernate will create proxy class

(Q)first level cache - second level cache
http://www.javalobby.org/java/forums/t48846.html


(Q)Different fetching strategies
(Q)Different cache strategies
(Q)Types of inheritence in classes

(Q) @JoinTable - @JoinColumn


==============================================

http://blog.jhades.org/setup-and-gotchas-of-the-hibernate-second-level-and-query-caches/
http://www.javalobby.org/java/forums/t48846.html


Difference bw get() and load()

get() : 
will fire SQL SELECT query
return actual object
if not found return null

load() :
it will return a proxy object, if you initialize the data for that object only then SELECT will be fired
only by calling load() method will not fire any sql
it will throw ObjectNotFoundException if entry not found


Hibernate Cache :

(1)First Level Cache :
first level cache works by default.
updates to an entity is updated to DB only once.
it is available at session level (or transaction level)

(2)Second level cache :
It is a cache which is available at SessionFactory level.
There must be a second level cache provider : EhCache, infispan
There is a default time configured for cache entries to evict (timeToLiveSeconds="2000" and memoryStoreEvictionPolicy="LRU").
We can also create different regions for different cache (like 4 caches for 4 different entities)
Data is stored in dehydrated manner , like a map of ({id:1}, {name:'akash',age:20})
LRU cache implementation (Least recently used)

@Cache is applied on entity which we want to cache
Strategies for second level cache :
READ_ONLY
READ_WRITE
TRANSACTIONAL


(3)Query Cache :
Query cache is used when data is actually fetched from DB via NamedQuery or Criteria
setCachable(true)
Internally it stores query (i.e. preparedStatement and its dynamic data) as key and values as id of entity
If a query is present in cache then fetches all its IDs
These IDs are first checked in Second level cache, if found then data is hydrated
if data not found in second level cache then SQL SELECT is fired for each ID .

hence it is necessary to use Query cache with second level cache .