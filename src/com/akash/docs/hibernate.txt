Hibernate

*** http://www.onjava.com/pub/a/onjava/2006/09/13/dont-let-hibernate-steal-your-identity.html?page=1

<version name="version"  unsaved-value="null" generated="always"  insert="true" />


Methods of Session class

get()
load()

save()
persist()

update()
saveOrUpdate()
merge()

delete()


Methods of EntityManager

find()
persist()
merge()
remove()

(Q)Difference b/w merge() and update() ?
Ans : 
update will fire only one sql for update
merge will first fire select (if entity is not loaded) and then update

update will throw exception if identifier not found
merge will add a new row if identifier not found

(Q)Difference b/w get() and load() ?
Ans :
When an entity already exists in DB we should use load()
It first checks in session cache then in DB.
if not found it throws exception
load() will return a proxied object.

get() can be used to check if entity exists in DB or not.
It returns null if not found


(Q)What is N+1 problem and how to resolve it ?
Ans :
There may be a scenario where we fetch an object and its children are fetch after that
As a result , their will be N+1 sql queries.
1 parent object can have N children
1 for the parent and
N for the children

To solve this we can load all entities in single sql as :
SELECT parent LEFT OUTER JOIN child

this query can also be used in HQL as :
FROM parent JOIN FETCH child 

NOTE : we can use this logic whenever we have to load full object graph.

(Q)Difference b/w save() and persist() ?
persist() method saves entities and their children inside a transaction.
persist() method throws TransactionRequiredException when it is used outside transaction

save() method can be used outside transaction, but then it will not save children entities.

save() with transaction ==== persist()

(Q)saveOrUpdate

It can be used outside transaction.
If used outside transaction then only parent entity saved.

NOTE : save() and saveOrUpdate() if used outside transaction, and you want to save mapped entities,
		you have to use session.flush()
		
Things that save data to DB :
(1)session.flush()
(2)transaction.commit()
(3)fire a DDL command, all queries before DDL command will be committed.
(4)fire HQL select command, all previous queries that include in SELECT HQL are commited.


Object is part of persistent context and tracked for any changes:
save()
saveOrUpdate()
merge()
update()
persist()

NOTE : One SessionFactory object is created for each Data source.

Session and Transaction
http://stackoverflow.com/questions/5409085/what-is-the-difference-between-a-session-and-a-transaction-in-jpa-2-0

JPA vs Hibernate
http://stackoverflow.com/questions/9881611/whats-the-difference-between-jpa-and-hibernate

======================================================


hibernate

http://www.javagyan.com/preparing-for-an-interview/hibernate-interview-questions
http://blog.jhades.org/setup-and-gotchas-of-the-hibernate-second-level-and-query-caches/
https://dzone.com/articles/sorting-collections-hibernate

(Q)get()-load()
(Q)merge()-update()
(Q)session - sessionfactory
(Q)session - transaction

(Q)
transient	: never persisted and not attached to a session
persisted	: attached to a unique session
detached	: previously persisted but not attached to session

(Q)how lazy loading works and why required ?
Related entity or collections in (OneToOne,OneToMany,ManyToMany) are not loaded when actual entity is loaded.
These are loaded by calling getters of proxy classes.
calling getter from proxy classes out of session will throw LazyInitializationException.
We can get actual implementation for proxy class.
entity = (T) ((HibernateProxy) entity).getHibernateLazyInitializer().getImplementation();

(Q)sorted and ordered collection

@OrderBy		-- to order list based on DB
@Sort			-- to order list in memory
@OrderColumn	-- to index the ordering

@javax.persistence.OrderBy("startYear, endYear")
@org.hibernate.annotations.Sort(type = SortType.COMPARATOR, comparator = EventCompator)
@org.hibernate.annotations.OrderBy("start_year, nvl(end_year , start_year)")

(Q)conditions while making your own entity class
-private fields , public getter/setter
-override equals() hashcode()
-create no-argument constructor
-do not make class as final,because hibernate will create proxy class

(Q)first level cache - second level cache
http://www.javalobby.org/java/forums/t48846.html


(Q)Different fetching strategies
(Q)Different cache strategies
(Q)Types of inheritence in classes

(Q) @JoinTable - @JoinColumn
