Understanding CGlib

http://mydailyjava.blogspot.in/2013/11/cglib-missing-manual.html
http://slurp.doc.ic.ac.uk/pubs/observing/linking.html
http://jnb.ociweb.com/jnb/jnbNov2005.html
http://www.artima.com/underthehood/invocationP.html 
http://zeroturnaround.com/rebellabs/java-bytecode-fundamentals-using-objects-and-calling-methods/



CGLIB is a byte code generation library which creates and link proxy classes at runtime.As java classes can be dynamically linked (http://slurp.doc.ic.ac.uk/pubs/observing/linking.html) , we can add new classes in running java program.It simply creates a subclass of your class or interface by reading its byte code.Under the hood it uses ASM which is a byte code manipulation framework.ASM helps CGLIB to generate java byte code at runtime.Frameworks like spring, hibernate, mockito uses CGLIB. Spring AOP uses proxy-based Aspect Oriented Programming which has a feature of method interception.Hibernate implemented a feature of returning proxy of an object of entity graph from database where child entities are fetched from database when required.Hibernate uses CGLIB for this feature.








* (1) private , static and final methods are not enhanced.
	 * 
	 * (2) The class generated by cglib will however be in the same package as
	 * the enhanced class (and therefore be able to override package-private
	 * methods).
	 * 
	 * (3) final classes are not enhanced.
	 * 
	 * (4) All cglib classes generate byte code which results in additional
	 * classes being stored in a special section of the JVM's memory: The so
	 * called perm space.
	 * 
	 * (5) Only those methods are proxied that are invokeVirtual. invokeSpecial
	 * and invokeStatic methods are not proxied. static methods are invokeStatic
	 * constructors, methods called using super keyword and private methods are
	 * invokeSpecial
	 * 
	 * (Q) public non-static methods inside private inner classes OR inside
	 * static inner classes ---> invokeVirtual or not
	 
	 
	 
	 
	 /**
	 * If interestingMethod() of Superclass is private then it is => invokeSpecial			<br>
	 * If interestingMethod() of Superclass is not private then it is => invokeVirtual		<br>
	 * 
	 *   javap -c -private Superclass.class		<br>
	 *   javap -c -private Subclass.class		<br>
	 */
	 
	 
	We can use implementation of following interfaces as a callback in Enhancer:
	MethodInterceptor
	NoOp
	LazyLoader
	Dispatcher
	InvocationHandler
	FixedValue
	
