Race condition : when multiple processes/threads access same resource and order of accessing resource matters.
Critical section : code that contains race condition

Thread safe : code that has no critical section

all local primitive variable are stored in thread stack
objects are stored in heap, so they can be shared with multiple threads

http://stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood
http://java.dzone.com/articles/painless-introduction-javas-threadlocal-storage

ThreadLocal
WeakRefrences

----------------------------------------------------------------

read-then-modify
check-then-act

intrinsic locks -> every object has its own intrinsic lock

reentrant 
synchronized (1)method , (2)block

race condition
visibility
stale object
long and double in 64 bit environment
volatile

thread confinement
ThreadLocal

Object publication and escape

Immutable objects 

final

combination of immutable and volatile

Two ways to handle concurrency in collection:
(1)throw exception when two threads read/write simultaneously,
this solution is still not thread safe as threads can see stale value.
(2)create new copy of collection while doing any operation, 
as thread will not have any impact on copy.
This might have some performance issues.

CopyOnWriteArrayList
***https://stackoverflow.com/questions/17853112/in-what-situations-is-the-copyonwritearraylist-suitable


NOTE:
we have to apply locking where a shared collection is iterated, to avoid ConcurrentModificationException 
In this example toString() method of HashSet uses iterator
While one thread is iterating over set other thread may add new elements.


====================================
@NotThreadSafe
public class UnsafeSequence {
	private int value;
	/** Returns a unique value. */
	public int getNext() {
		return value++;
	}
}

UnsafeSequence illustrates a common concurrency hazard called a race condition.

@ThreadSafe
public class Sequence {
	@GuardedBy("this") private int value;
	public synchronized int getNext() {
		return value++;
	}
}

Whenever more than one thread accesses a given state variable, and one of them might
write to it, they all must coordinate their access to it using synchronization.

What is thread safety:
No set of operations performed sequentially or concurrently
on instances of a thread-safe class can cause an instance to be in an invalid
state.


A stateless Servlet:

@ThreadSafe
public class StatelessFactorizer implements Servlet {
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		encodeIntoResponse(resp, factors);
	}
}


Atomicity:

@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
	private long count = 0;
	public long getCount() { return count; }
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		++count;
		encodeIntoResponse(resp, factors);
	}
}

thread 1 : get count(0)		---		inc 0 to 1		----	set count(1)
thread 2 : 							get count(0)	----	inc 0 to 1		---		set count(1)
thread 3 : 													get count(1)	---		inc 1 to 2 		---		set count(2)

it is not atomic, which
means that it does not execute as a single, indivisible operation. Instead, it is a
shorthand for a sequence of three discrete operations: fetch the current value, add
one to it, and write the new value back. This is an example of a read-modify-write
operation, in which the resulting state is derived from the previous state.

read-modify-write causes operations to be non-Atomic.

Race Condition :

The most common
type of race condition is check-then-act, where a potentially stale observation is
used to make a decision on what to do next.

Check-then-Act  problem causes Race Condition in multiple threads.

Race condition can be understood as a problem in which 
reaching the desired outcome depends on the relative timing of events.

This type of race condition
is called check-then-act: you observe something to be true (file X doesn’t
exist) and then take action based on that observation (create X); but in fact the
observation could have become invalid between the time you observed it and the
time you acted on it (someone else created X in the meantime), causing a problem
(unexpected exception, overwritten data, file corruption).

Race Condition in Lazy Initialization:

A common idiom that uses check-then-act is lazy initialization.

@NotThreadSafe
public class LazyInitRace {
	private ExpensiveObject instance = null;
	public ExpensiveObject getInstance() {
		if (instance == null)
			instance = new ExpensiveObject();
		return instance;
	}
}

LazyInitRace has race conditions that can undermine its correctness. Say that
threads A and B execute getInstance at the same time. A sees that instance
is null, and instantiates a new ExpensiveObject. B also checks if instance is
null. Whether instance is null at this point depends unpredictably on timing,
including the vagaries of scheduling and how long A takes to instantiate the ExpensiveObject
and set the instance field.

Compound actions:

@ThreadSafe
public class CountingFactorizer implements Servlet {
	private final AtomicLong count = new AtomicLong(0);
	public long getCount() { return count.get(); }
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		count.incrementAndGet();
		encodeIntoResponse(resp, factors);
	}
}


Locking :

@NotThreadSafe
public class UnsafeCachingFactorizer implements Servlet {
	private final AtomicReference<BigInteger> lastNumber
	= new AtomicReference<BigInteger>();
	private final AtomicReference<BigInteger[]> lastFactors
	= new AtomicReference<BigInteger[]>();
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		if (i.equals(lastNumber.get()))
			encodeIntoResponse(resp, lastFactors.get());
		else {
			BigInteger[] factors = factor(i);
			lastNumber.set(i);
			lastFactors.set(factors);
			encodeIntoResponse(resp, factors);
		}
	}
}
methods of AtomicReference
	V updateAndGet(UnaryOperator<V> updateFunction)
	

The definition of thread safety requires that invariants be preserved regardless
of timing or interleaving of operations in multiple threads. One invariant of UnsafeCachingFactorizer
is that the product of the factors cached in lastFactors
equal the value cached in lastNumber; our servlet is correct only if this invariant
always holds.

An Invariant is a non-changing condition in our program that decides the successful implementation.
here:
last number must be equal multiplication of last factors

Just as AtomicLong is a thread-safe holder class for a long integer, AtomicReference is a threadsafe
holder class for an object reference.



Intrinsic Lock :

A synchronized
block has two parts: a reference to an object that will serve as the lock, and a
block of code to be guarded by that lock. A synchronized method is a shorthand
for a synchronized block that spans an entire method body, and whose lock is
the object on which the method is being invoked. (Static synchronized methods
use the Class object for the lock.)
synchronized (lock) {
// Access or modify shared state guarded by lock
}
Every Java object can implicitly act as a lock for purposes of synchronization;
these built-in locks are called intrinsic locks or monitor locks. The lock is automatically
acquired by the executing thread before entering a synchronized block
and automatically released when control exits the synchronized block, whether
by the normal control path or by throwing an exception out of the block.


Intrinsic locks in Java act as mutexes (or mutual exclusion locks), which means
that at most one thread may own the lock.

@ThreadSafe
public class SynchronizedFactorizer implements Servlet {
	@GuardedBy("this") private BigInteger lastNumber;
	@GuardedBy("this") private BigInteger[] lastFactors;
	public synchronized void service(ServletRequest req,ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		if (i.equals(lastNumber))
			encodeIntoResponse(resp, lastFactors);
		else {
			BigInteger[] factors = factor(i);
			lastNumber = i;
			lastFactors = factors;
			encodeIntoResponse(resp, factors);
		}
	}
}

This has poor performance.


Reentrant or Reentrancy :

When a thread requests a lock that is already held by another thread, the requesting
thread blocks. But because intrinsic locks are reentrant, if a thread tries
to acquire a lock that it already holds, the request succeeds. Reentrancy means
that locks are acquired on a per-thread rather than per-invocation basis.
When the count is zero, the lock is considered unheld. When a
thread acquires a previously unheld lock, the JVM records the owner and sets the
acquisition count to one. If that same thread acquires the lock again, the count
is incremented, and when the owning thread exits the synchronized block, the
count is decremented. When the count reaches zero, the lock is released.


public class Widget {
	public synchronized void doSomething() {
		...
	}
}

public class LoggingWidget extends Widget {
	public synchronized void doSomething() {
		System.out.println(toString() + ": calling doSomething");
		super.doSomething();
	}
}


A common locking convention is to encapsulate all mutable state within an
object and to protect it from concurrent access by synchronizing any code path
that accesses mutable state using the object’s intrinsic lock. This pattern is used
by many thread-safe classes, such as Vector and other synchronized collection
classes.
Not all data needs to be guarded by locks—only mutable data that will be
accessed from multiple threads.


@ThreadSafe
public class CachedFactorizer implements Servlet {
	@GuardedBy("this") private BigInteger lastNumber;
	@GuardedBy("this") private BigInteger[] lastFactors;
	@GuardedBy("this") private long hits;
	@GuardedBy("this") private long cacheHits;
	public synchronized long getHits() { return hits; }
	public synchronized double getCacheHitRatio() {
		return (double) cacheHits / (double) hits;
	}
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = null;
		synchronized (this) {
			++hits;
			if (i.equals(lastNumber)) {
				++cacheHits;
				factors = lastFactors.clone();
			}
		}
		if (factors == null) {
			factors = factor(i);
			synchronized (this) {
				lastNumber = i;
				lastFactors = factors.clone();
			}
		}
		encodeIntoResponse(resp, factors);
	}
}

===================================================================================

=====Chapter 3======

synchronized is not only about atomicity or demarcating “critical sections”. Synchronization also
has another significant, and subtle, aspect: memory visibility. We want not only to
prevent one thread from modifying the state of an object when another is using it,
but also to ensure that when a thread modifies the state of an object, other threads
can actually see the changes that were made.

In order to ensure visibility of memory writes across threads, you must use synchronization.

Visibilty :

public class NoVisibility {
	private static boolean ready;
	private static int number;
	private static class ReaderThread extends Thread {
		public void run() {
			while (!ready)
				Thread.yield();
			System.out.println(number);
		}
	}
	public static void main(String[] args) {
		new ReaderThread().start();
		number = 42;
		ready = true;
	}
}



Stale data can cause serious and confusing failures such as unexpected exceptions,
corrupted data structures, inaccurate computations, and infinite loops.

Synchronizing only the setter would not be sufficient: threads calling get 
 would still be able to see stale values.
 

@NotThreadSafe
public class MutableInteger {
	private int value;
	public int get() { return value; }
	public void set(int value) { this.value = value; }
}


@ThreadSafe
public class SynchronizedInteger {
	@GuardedBy("this") private int value;
	public synchronized int get() { return value; }
	public synchronized void set(int value) { this.value = value; }
}

out-of-thin-air safety :

When a thread reads a variable without synchronization, it may see a stale value,
but at least it sees a value that was actually placed there by some thread rather
than some random value.
This safety guarantee is called out-of-thin-air safety.
Out-of-thin-air safety applies to all variables, with one exception: 
64-bit numeric variables (double and long) that are not declared volatile .
 The Java Memory Model requires fetch and store operations to be atomic,
but for nonvolatile long and double variables, the JVM is permitted to treat a
64-bit read or write as two separate 32-bit operations.


Locking and Visibilty :
Intrinsic locking can be used to guarantee that one thread sees the effects of another in a predictable manner.


Volatile variable :

weaker form of synchronization.

When a field is declared volatile, the compiler and runtime
are put on notice that this variable is shared and that operations on it should not
be reordered with other memory operations. Volatile variables are not cached in
registers or in caches where they are hidden from other processors, so a read of a
volatile variable always returns the most recent write by any thread.

When thread A writes to a volatile variable and subsequently
thread B reads that same variable, the values of all variables that were
visible to A prior to writing to the volatile variable become visible to B after
reading the volatile variable.


variables are copied from main memory to cpu cache and then processed by cpu registers.
If we have more than 1 cpu,
then 2 threads processed by different cpu, have different cpu cache for same variable.



____________			_____________________
|			|			|					|
|	CPU	1	|			|	CPU 1 cache  	|
|_Registers_|			|___________________|

												-------------> Main Memory

____________			_____________________
|			|			|					|
|	CPU	2	|			|	CPU 2 cache  	|
|_Registers_|			|___________________|


When not using volatile variable, we do not know when cpu cache value is written back to main memory.

NOTE :
Making a variable volatile is not enough.
If a variable is read and written by many threads, then we may fall in a race condition.
For example Read-Modify-Write scenario.

To overcome this we have 2 solutions:
(1)Use synchronized keyword
(2)Use AtomicLong or AtomicRefrence  which are classes in java.util.concurrent package


----------

Publishing and escape :

Publishing an object means making it available to code outside of its current scope,
such as by storing a reference to it where other code can find it, returning it
from a nonprivate method, or passing it to a method in another class.


-->storing a refrence in public static field

	public static Set<Secret> knownSecrets;
	public void initialize() {
		knownSecrets = new HashSet<Secret>();
	}
	
	
-->Returning a refrence from a non-private method

	class UnsafeStates {
		private String[] states = new String[] {
			"AK", "AL" ...
		};
		public String[] getStates() { return states; }
	}
	
-->Any fields of a nonprivate refrence are also considered as published

-->overridable methods (neither private nor final)

***IMP
-->publish an inner class instance

Do not allow the this reference to escape during construction.

-->Avoid calling thread.start() method from inside the constructor

https://stackoverflow.com/questions/12467101/how-this-escapes-from-a-published-inner-class/12467202#12467202
http://www.ibm.com/developerworks/java/library/j-jtp0618/index.html


public class ThisEscape {

    public Integer i = 47;

    public ThisEscape(EventSource source) {
            source.registerListener(
                    new EventListener() {
                            ThisEscape outerRef = ThisEscape.this;//added by compiler
                            public void onEvent(Event e) {
                                    doSomething(e);
                            }
                    });
    }
}

public class EventSource {
    public void registerListener(EventListener listener) {
        
    }
}


Problem with this approach is that, you can have a situation where inner class will use your class object
 and your class object is still in construction. Same problem exists with starting thread from constructor.
 
class MyThread implements Runnable {
	
	private Thread thread;
	
	MyThread() {
		thread = new Thread(this);	//creating a thread here and passing this is ok,
		thread.start();				//but never start thread in constructor
	}
	
	public void run() {
		...
	}
}

->Never create inner classes in the constructor, either anonymous, local, static or non-static
->Avoid any transitive combination of the rules above, i.e. 
don't create an anonymous inner class in a private or protected final method that is invoked from within the constructor
->Exposing this reference from constructor :
		->setting this in a static field
		->adding this in a collection
		->publishing this via non-static inner class
		

public class Safe { 

  private Object me;
  private Set set = new HashSet();
  private Thread thread;

  public Safe() { 
    // Safe because "me" is not visible from any other thread
    me = this;

    // Safe because "set" is not visible from any other thread
    set.add(this);

    // Safe because MyThread won't start until construction is complete
    // and the constructor doesn't publish the reference
    thread = new MyThread(this);
  }

  public void start() {
    thread.start();
  }

  private class MyThread(Object o) {
    private Object theObject;

    public MyThread(Object o) { 
      this.theObject = o;
    }

    ...
  }
}

public class Unsafe {
  public static Unsafe anInstance;
  public static Set set = new HashSet();
  private Set mySet = new HashSet();

  public Unsafe() {
    // Unsafe because anInstance is globally visible
    anInstance = this;

    // Unsafe because SomeOtherClass.anInstance is globally visible
    SomeOtherClass.anInstance = this;

    // Unsafe because SomeOtherClass might save the "this" reference
    // where another thread could see it
    SomeOtherClass.registerObject(this);

    // Unsafe because set is globally visible 
    set.add(this);

    // Unsafe because we are publishing a reference to mySet
    mySet.add(this);
    SomeOtherClass.someMethod(mySet);

    // Unsafe because the "this" object will be visible from the new
    // thread before the constructor completes
    thread = new MyThread(this);
    thread.start();
  }

  public Unsafe(Collection c) {
    // Unsafe because "c" may be visible from other threads
    c.add(this);
  }
}


Thread Confinement :

https://www.quora.com/Java-programming-language/What-are-some-tips-tricks-and-gotchas-when-using-ThreadLocal
http://stackoverflow.com/questions/11283369/how-does-threadlocal-usage-reduce-reusability

/**
*	Every thread has its own map
*	key of map = threadlocal object
*	value of map = value to be stored in threadlocal
*/

class Thread {
	ThreadLocal.ThreadLocalMap threadLocals = null;
}

class ThreadLocal {
	
	static class ThreadLocalMap {
		private Entry[] table;
		static class Entry extends WeakReference<ThreadLocal<?>> {
			Object value;
		}
	}
	
	public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = t.threadLocals;
        ThreadLocalMap.Entry e = map.get(this);
        return e.value;
	}

	public void set(T value) {
		Thread t = Thread.currentThread();
		ThreadLocalMap map = t.threadLocals;
		map.set(this, value);
	}
	
	public void remove() { 
		Thread t = Thread.currentThread();
		ThreadLocalMap map = t.threadLocals;
		map.set(this);
	}
}

It is easy to abuse ThreadLocal by treating its thread confinement property as
a license to use global variables or as a means of creating “hidden” method arguments.
Like global variables, thread-local variables can detract from reusability
and introduce hidden couplings among classes, and should therefore be used
with care.

Immutable Objects :

Immutable objects are always thread-safe.
Their invariants are established by the constructor, 
and if their state cannot be changed, these invariants always hold.

Whenever a group of related data items must
be acted on atomically, consider creating an immutable holder class for them,
such as OneValueCache.

@Immutable
class OneValueCache {
	private final BigInteger lastNumber;
	private final BigInteger[] lastFactors;
	public OneValueCache(BigInteger i,
	BigInteger[] factors) {
		lastNumber = i;
		lastFactors = Arrays.copyOf(factors, factors.length);
	}
	public BigInteger[] getFactors(BigInteger i) {
		if (lastNumber == null || !lastNumber.equals(i))
			return null;
		else
			return Arrays.copyOf(lastFactors, lastFactors.length);
	}
}

@ThreadSafe
public class VolatileCachedFactorizer implements Servlet {
	private volatile OneValueCache cache = new OneValueCache(null, null);
	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = cache.getFactors(i);
			if (factors == null) {
				factors = factor(i);
				cache = new OneValueCache(i, factors);
			}
		encodeIntoResponse(resp, factors);
	}
}

Immutable and Affectively immutable classes :

http://stackoverflow.com/questions/16678416/different-between-immutable-and-effectively-immutable-objects

Affectively Immutable class is when class has mutable instance variables but are not published as public.
for eg , having a ArrayList in a class and returning its copy from getter method.
Or having a mutable object with returning its copy from getter.

Truly Immutable class is when all its instance variables are immutable.

properties of Immutable class :
->setting all instance variables in constructor
->removing setters
->passing copy of mutable object from getter method
->making class final
->hashcode of immutable objects must be cashed



====================================================================================================
http://www.programmr.com/blogs/what-every-java-developer-should-know-strong-and-weak-references
https://web.archive.org/web/20061130103858/http://weblogs.java.net/blog/enicholas/archive/2006/05/understanding_w.html

** strong, soft, weak, and phantom, in order from strongest to weakest

=>Strong References :

	Widget w = new Widget();

A Widget object is created on the heap, and the variable w holds a reference to that object. 
As long as the variable w is active, the object which it points to (Widget) will not be garbage collected.
That is why this is known as Strong Reference.
Strong because the object referenced by it cannot be garbage collected against its will.


=>Weak References :

Objects referenced by Weak Reference may be garbage collected,
if the JVM runs short of memory, even when they are being used.
 
WeakReference<String> wr = new WeakReference<String>(new String("abc"));

	String s = wr.get();
	if(s != null ) {
	    // great the weak ref has not been garbage collected
	} else {
	    // oops the weak ref was garbage collected... now I will have to create another one
	}
	
The most common use for weak references are read-only caches, where losing an object is not disastrous.
We can also use WeakHashMap for these kind of caches.

====================================================================================================

============Chapter 4===========

The design process for a thread-safe class should include these three basic elements:
• Identify the variables that form the object’s state;
• Identify the invariants that constrain the state variables;
• Establish a policy for managing concurrent access to the object’s state.



==========================================================================================================

============Chapter 5===========

=>Problems with synchronised collections

when there is a gap b/w locking state of object and synchronization methods

=>Iterators and ConcurrentModificationException

The standard way to iterate a Collection is with an Iterator, 
either explicitly or through the for-each loop syntax introduced in Java 5.0.

-->
for (int i = 0; i < list.size(); i++) {
    Thing t = list.get(i);
    ...
}
This kind of loop isn't always possible.For example,
** Lists have indices, but Sets don't, because they're unordered collections.

-->
for (Thing thing : list) {
    ...
}
This works with every kind of Iterable collection (or array)

-->
for (Iterator<Thing> it = list.iterator(); it.hasNext(); ) {
    Thing t = it.next();
    ...
}

for (Iterator<Thing> it = list.iterator(); it.hasNext(); ) {
    Thing t = it.next();
    if (shouldBeDeleted(thing) {
        it.remove();
    }
}

An Iterator can do things that a foreach loop can't. For example,
** you can remove/add elements while you're iterating, if the iterator supports it
** Lists also offer iterators that can iterate in both directions.
    A foreach loop only iterates from the beginning to an end.
** using list.get(index) in for loop for LinkedList is not good for performance.

Iterators has been provided with methods : add, remove, set
Once an iterator is created for traversing a collection,
you cannot modify that collection by some another thread (ConcurrentModificationException).
You can modify that collection by iterator.


The iterators returned by the synchronized collections are not designed to deal with concurrent modification,
 and they are fail-fast—meaning that if they detect that the collection has changed since iteration began,
 they throw the unchecked ConcurrentModificationException. 
**classes that throw ConcurrentModificationException :
	HashMap, HashSet, ArrayList, LinkedList, TreeMap, TreeSet, Collections.synchronizedList, synchronizedMap


to avoid ConcurrentModificationException, a lock should be applied before iterator
Another way of iterating is to make a copy of collection when any modification occurs
**Classes that copy collection upon modification:
	CopyOnWriteArrayList, CopyOnWriteArraySet

copy cost performance
locking cost time wait for other threads

=>Hidden iterators

public class HiddenIterator {
    @GuardedBy("this")
    private final Set<Integer> set = new HashSet<Integer>();

    public synchronized void add(Integer i) { set.add(i); }

    public synchronized void remove(Integer i) { set.remove(i); }

    public void addTenThings() {
        Random r = new Random();
        for (int i = 0; i < 10; i++)
            add(r.nextInt());
        System.out.println("DEBUG: added ten elements to " + set);
    }
}

The addTenThings method could throw ConcurrentModificationException ,
because the collection is being iterated by toString in the process of preparing
the debugging message. Of course, the real problem is that HiddenIterator is
not thread-safe; the HiddenIterator lock should be acquired before using set in
the println call,

greater the distance between the state and the synchronization that guards it, 
the more likely that someone will forget to use proper synchronization when accessing that state. 

Iteration is also indirectly invoked by the collection’s hashCode and equals methods,
Similarly, the containsAll , removeAll , and retainAll methods,
as well as the constructors that take collections as arguments, also iterate the collection.
All of these indirect uses of iteration can cause ConcurrentModificationException .


=>Concurrent Collection

 Synchronized collections achieve their thread safety by serializing all access to the collection’s state. 
 The cost of this approach is poor concurrency; 
 when multiple threads contend for the collection-wide lock, throughput suffers. 
 	Map<> map = Collections.synchronizedMap(new HashMap<Integer, Integer>());
 	Set<> set = Collections.synchronizedSet(new HashSet<Integer>());
 	synchronizedList
 	synchronizedSortedSet
 	synchronizedSortedMap


ConcurrentHashMap  -- synchronised hashMap -- hashMap
CopyOnWriteArrayList  --  synchronised list  -- ArrayList
ConcurrentSkipListMap  --  TreeMap
ConcurrentSkipListSet  --  TreeSet

Queue -- operations are not blocked
	linkedList
BlockingQueue  -- operations are blocked
	LinkedBlockingQueue, ArrayBlockingQueue


=>ConcurrentHashMap


Types of Iterators :

fail fast
	-> iterators throw ConcurrentModificationException when any modification done in 
		collection after creating iterator.
	-> eg: HashMap, HashSet, ArrayList, LinkedList, TreeMap, TreeSet
fail safe 
	-> The term "fail-safe" isn't used anywhere in official Java documentation
	-> iterators do not throw ConcurrentModificationException
	-> CopyOnWriteArrayList, CopyOnWriteArraySet
	-> whenever collection is modified(element added or removed), a new copy is created
		and while creating an iterator, snapshot of collection is taken
		so any modification on collection will not impact on this snapshot 
	-> The only guarantee is that the elements seen by the iteration were present in the input at some point.
		That's a pretty weak guarantee.
		
weakly consistent
	-> iterators do not throw ConcurrentModificationException
	-> ConcurrentHashMap
	-> they are guaranteed to traverse elements as they existed upon construction exactly once, 
		and may (but are not guaranteed to) reflect any modifications subsequent to construction.
		
		
		
**fail fast iteration
	List<String> input = Arrays.asList("a", "b", "c", "d", "e");
	List<String> output = new ArrayList<>();

	Deque<String> deque = new LinkedList<>(input);
	for (String s : deque) {
		output.add(s);
		if (s.equals("c")) {
			deque.addFirst("XXX");
			deque.removeLast();
		}
	}
	
	//ConcurrentModificationException at runtime
	
**weakly consistent iteration
	List<String> input = Arrays.asList("a", "b", "c", "d", "e");
	List<String> output = new ArrayList<>();

	Deque<String> deque = new ConcurrentLinkedDeque<>(input);
	for (String s : deque) {
		output.add(s);
		if (s.equals("c")) {
			deque.addFirst("XXX");
			deque.removeLast();
		}
	}
	
	//the output list is [a, b, c, d]
	 the output list reflects only some of the modifications that were made to the input during the iteration

**for loop with index (different from iterator)
	List<String> input = Arrays.asList("a", "b", "c", "d", "e");
    List<String> output = new ArrayList<>();

    List<String> arrayList = new ArrayList<>(input);
    for (int i = 0; i < arrayList.size(); i++) {
        String s = arrayList.get(i);
        output.add(s);
        if (i == 2) {                   // <<< MODIFY
            arrayList.add(0, "XXX");
        }
    }
	
	// the output list is [a, b, c, c, d, e]

*** Try to avoid traversing list via index, as it will not throw ConcurrentModificationException.
	 
	Weakly consistent iteration provides guarantees against repeated elements and 
	against a variety of errors or infinite loops that can occur. 
	The "weakness" is that they provide few guarantees about exactly which elements are observed during iteration.
	
https://stackoverflow.com/questions/28915215/iterator-type-in-java-weakly-consistent?rq=1
https://stackoverflow.com/questions/20142493/fail-safe-iterators-and-weakly-consistent-iterators


(Q) How ConcurrentHashMap calculates its size?
It can use AtomicLong for this operation
but it uses CounterCell which is adapted for LongAdder and Striped64


=>CopyOnWriteArrayList 

copy-on-write collections
	->when traversal operations vastly out number mutations
	->when you cannot or don't want to synchronize traversals
	->"snapshot" style iterator method, reference to the state of the collection at the point that the iterator was created
	->iterator will never throw ConcurrentModificationException
	->Not good for frequent modification in collection
	

This criterion exactly describes many event-notification systems:
 delivering a notification requires iterating the list of registered listeners and calling each one of them,
 and in most cases registering or unregistering an event listener is far less 
 common than receiving an event notification. 
 
 
=>Blocking queues and the producer-consumer pattern

 The producer consumer pattern simplifies development because it removes code dependencies
 between producer and consumer classes, and simplifies workload management by
 decoupling activities that may produce or consume data at different or variable rates. 

Bounded queues are a powerful resource management tool for building reliable applications: 
they make your program more robust to overload by throttling activities that threaten 
to produce more work than can be handled.



=>Blocking and interruptible methods


public void interrupt() {
	synchronized (blockerLock) {
		Interruptible b = blocker;
		if (b != null) {
			interrupt0();           // Just to set the interrupt flag
			b.interrupt(this);
			return;
		}
	}
	interrupt0();
}

->If this thread is blocked in an invocation of the wait(), join(), sleep(long) methods,
	then its interrupt status will be cleared and it will receive an InterruptedException.
->If this thread is blocked in an I/O operation upon an InterruptibleChannel then
	the channel will be closed, the thread's interrupt status will be set, and 
	the thread will receive a java.nio.channels.ClosedByInterruptException. 
->If none of the previous conditions hold then this thread's interrupt status will be set. 

=====================================================

//true if this thread has been interrupted; false otherwise.
//The interrupted status of the thread is cleared by this method.
//if there is an interrupt, then first call will return true and status is cleared
//second call will return false.
//third call will also return false

public static boolean interrupted() {
	return currentThread().isInterrupted(true);
}

=====================================================

//true if this thread has been interrupted; false otherwise.
//The interrupted status of the thread is unaffected by this method

public boolean isInterrupted() {
	return isInterrupted(false);
}

=====================================================

/**
 * Tests if some Thread has been interrupted.  The interrupted state
 * is reset or not based on the value of ClearInterrupted that is
 * passed.
 */
private native boolean isInterrupted(boolean ClearInterrupted);

=====================================================

private native void interrupt0();

=====================================================

When a method can throw InterruptedException, it is telling you that it is a blocking method,
 and further that if it is interrupted, it will make an effort to stop blocking early.
 Thread provides the interrupt() method for interrupting a thread
 and for querying whether a thread has been interrupted.
 Each thread has a boolean property that represents its interrupted status;
 interrupting a thread sets this status.
 Interruption is a cooperative mechanism.
 One thread cannot force another to stop what it is doing and do something else;
 when thread A interrupts thread B, A is merely requesting that B stop what it is doing
 when it gets to a convenient stopping point—if it feels like it. 
 
 When your code calls a method that throws InterruptedException, 
 then your method is a blocking method too, and must have a plan for responding to interruption.
 For library code, there are basically two choices
 1) Propagate the InterruptedException
	just propagate the InterruptedException to your caller. 
	->not catching InterruptedException
	->catching it and throwing it again after performing some brief activity-specific cleanup
2) Restore the interrupt
	you must catch InterruptedException and restore the interrupted status by calling interrupt
	on the current thread, so that code higher up the call stack can see that an interrupt was issued

	public class TaskRunnable implements Runnable {
		...
		public void run() {
			try {
				processTask(queue.take()); 
			} catch (InterruptedException e) { 
				// restore interrupted status 
				Thread.currentThread().interrupt(); 
			} 
		}
	}
	


=>Synchronizers

--->Latches
A latch is a synchronizer that can delay the progress of threads until it reaches its terminal state. 
A latch acts as a gate:
Once the latch reaches the terminal state, it cannot change state again, so it remains open forever

eg :
 ->Waiting until all the parties involved in an activity, 
 for instance the players in a multi-player game, are ready to proceed
 
 ->how long it takes to run a task n times concurrently
 
The countDown() method decrements the counter, indicating that an event has occurred, 
and the await() methods wait for the counter to reach zero, 
which happens when all the events have occurred. 
If the counter is nonzero on entry, await blocks until the counter reaches zero,
 the waiting thread is interrupted, or the wait times out. 
 
 
--->FutureTask

states : 	waiting to run
			Running
			Completed
				->completion
				->cancellation
				->Exception
				
 Once a FutureTask enters the completed state, it stays in that state forever. 
 FutureTask is used by the Executor framework to represent asynchronous tasks.
 

--->Semaphores 

--->Barriers 


=>Building an efficient, scalable result cache

***Memoizer1

public interface Computable<A, V> {
	V compute(A arg) throws InterruptedException; 
}
public class ExpensiveFunction implements Computable<String, BigInteger> {
	public BigInteger compute(String arg) {
		// after deep thought... 
		return new BigInteger(arg); 
	}
}
public class Memoizer1<A, V> implements Computable<A, V> {
	@GuardedBy("this") 
	private final Map<A, V> cache = new HashMap<A, V>(); 
	private final Computable<A, V> c;
	public Memoizer1(Computable<A, V> c) {
		this.c = c;
	}
	public synchronized V compute(A arg) throws InterruptedException {
		V result = cache.get(arg);
		if (result == null) {
			result = c.compute(arg);
			cache.put(arg, result);
		}
		return result;
	}
}


***Memoizer2

public class Memoizer2<A, V> implements Computable<A, V> {
	private final Map<A, V> cache = new ConcurrentHashMap<A, V>();
	private final Computable<A, V> c;
	public Memoizer2(Computable<A, V> c) {
		this.c = c;
	}
	public V compute(A arg) throws InterruptedException {
		V result = cache.get(arg);
		if (result == null) {
			result = c.compute(arg);
			cache.put(arg, result);
		}
		return result;
	}
}



***Memoizer3

public class Memoizer3<A, V> implements Computable<A, V> {
	private final Map<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>();
	private final Computable<A, V> c;
	public Memoizer3(Computable<A, V> c) {
		this.c = c;
	}
	public V compute(final A arg) throws InterruptedException {
		Future<V> f = cache.get(arg);
		if (f == null) {
			Callable<V> eval = new Callable<V>() {
				public V call() throws InterruptedException { 
					return c.compute(arg); 
				} 
			}; 
			FutureTask<V> ft = new FutureTask<V>(eval);
			f = ft;
			cache.put(arg, ft);
			ft.run(); // call to c.compute happens here 
		} 
		try { 
			return f.get(); 
		} catch (ExecutionException e) { 
			throw launderThrowable(e.getCause()); 
		} 
	}
}



***Memoizer4

public class Memoizer<A, V> implements Computable<A, V> {
	private final ConcurrentMap<A, Future<V>> cache = new ConcurrentHashMap<A, Future<V>>(); 
	private final Computable<A, V> c;
	public Memoizer(Computable<A, V> c) { 
		this.c = c; 
	}
	public V compute(final A arg) throws InterruptedException {
		while (true) {
			Future<V> f = cache.get(arg); 
			if (f == null) { 
				Callable<V> eval = new Callable<V>() {
					public V call() throws InterruptedException { 
						return c.compute(arg); 
					} 
				}; 
				FutureTask<V> ft = new FutureTask<V>(eval);
				f = cache.putIfAbsent(arg, ft);
				if (f == null) {
					f = ft; 
					ft.run();
				} 
			} 
			try { 
				return f.get(); 
			} catch (CancellationException e) { 
				cache.remove(arg, f); 
			} catch (ExecutionException e) { 
				throw launderThrowable(e.getCause()); 
			} 
		} 
	}
}



@ThreadSafe 
public class Factorizer implements Servlet { 
	private final Computable<BigInteger, BigInteger[]> c = new Computable<BigInteger, BigInteger[]>() {
		public BigInteger[] compute(BigInteger arg) {
			return factor(arg); 
		} 
	}; 
	private final Computable<BigInteger, BigInteger[]> cache = new Memoizer<BigInteger, BigInteger[]>(c);
	public void service(ServletRequest req, ServletResponse resp) {
		try {
			BigInteger i = extractFromRequest(req); 
			encodeIntoResponse(resp, cache.compute(i)); 
		} catch (InterruptedException e) {
			encodeError(resp, "factorization interrupted"); 
		}
	}
}



=>Concurrency Cheat Sheet

• It’s the mutable state, stupid.1 All concurrency issues boil down to coordinating access to mutable state.
 The less mutable state, the easier it is to ensure thread safety.

 • Make fields final unless they need to be mutable.

 • Immutable objects are automatically thread-safe. 
 	Immutable objects simplify concurrent programming tremendously. 
 	They are simpler and safer, and can be shared freely without locking or defensive copying.

 • Encapsulation makes it practical to manage the complexity. 
 	You could write a thread-safe program with all data stored in global variables, 
 	but why would you want to? 
 	Encapsulating data within objects makes it easier to preserve their invariants; 
 	encapsulating synchronization within objects makes it easier to comply with their synchronization policy.

 • Guard each mutable variable with a lock.

 • Guard all variables in an invariant with the same lock.

 • Hold locks for the duration of compound actions.

 • A program that accesses a mutable variable from multiple threads without synchronization is a broken program.

 • Don’t rely on clever reasoning about why you don’t need to synchronize.

 • Include thread safety in the design process—or explicitly document that your class is not thread-safe.

 • Document your synchronization policy.


==========================================================================================================


========================Chapter 6========================

=> Sequential web server.

class SingleThreadWebServer {
	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			Socket connection = socket.accept();
			handleRequest(connection);
		}
	}
}


it can handle only one request at a time
rarely provides either good throughput or good responsiveness


=> Web server that starts a new thread for each request

class ThreadPerTaskWebServer {
	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			final Socket connection = socket.accept();
			Runnable task = new Runnable() {
				public void run() {
					handleRequest(connection);
				}
			};
			new Thread(task).start();
		}
	}
}

Features :
 resume waiting for the next incoming connection more quickly
 Tasks can be processed in parallel
 
 As long as the request arrival rate does not exceed the 
 server’s capacity to handle requests, 
 this approach offers better responsiveness and throughput.
 
Disadvantage :
-> Thread creation and tear down are not free. thread creation takes time
-> If you have enough threads to keep all the CPUs busy, creating more threads won’t help and may even hurt. 
->  There is a limit on how many threads can be created.
	 requested stack size in the Thread constructor, and 
	 limits on threads placed by the underlying operating system
	 
public interface Executor {
	void execute(Runnable command);
} 

->  Executor processes tasks asynchronously
-> It provides a standard means of decoupling task submission from task execution,
-> The Executor implementations also provide lifecycle support and 
 hooks for adding statistics gathering, application management, and monitoring
	hooks : 
		-> number of alive threads 
		-> waiting task queue size
		-> ThreadFactory
		-> RejectedExecutionHandler


class TaskExecutionWebServer {
	private static final int NTHREADS = 100;
	private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);

	public static void main(String[] args) throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (true) {
			final Socket connection = socket.accept();
			Runnable task = new Runnable() {
				public void run() {
					handleRequest(connection);
				}
			};
			exec.execute(task);
		}
	}
}

Executor is based on the producer-consumer pattern, 
where activities that submit tasks are the producers (producing units of work to be done)
 and the threads that execute tasks are the consumers (consuming those units of work). 


Whenever you see code of the form: 
	new Thread(runnable).start()
 and you think you might at some point want a more ﬂexible execution policy,
 seriously consider replacing it with the use of an Executor.

=> Types of thread Pool
newFixedThreadPool
newCachedThreadPool
newSingleThreadExecutor
newScheduledThreadPool

(Q) why cached thread pool uses SynchronousQueue
-> newScheduledThreadPool uses DelayedWorkQueue


Submitting a task with execute adds the task to the work queue, 
and the worker threads repeatedly dequeue tasks from the work queue and execute them. 


---------------------------------------

=> Executor lifecycle 

the JVM can’t exit until all the (nondaemon) threads have terminated, 
so failing to shut down an Executor could prevent the JVM from exiting. 

two types of shutdown
-> gracefull shutdown
-> abrupt shutdown

If an executor application shuts down, it has to send information of all tasks status:
-> task can completed , no information required
-> task may be cancelled , info required
-> task may not be started, info required

To address above requirements, ExecutorService interface extends Executor, 
adding a number of methods for lifecycle management 


public interface ExecutorService extends Executor {
	void shutdown(); 
	List<Runnable> shutdownNow(); 
	boolean isShutdown(); 
	boolean isTerminated(); 
	boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; 
	// ... additional convenience methods for task submission 
} 


=>ExecutorService has 3 life cycle stages :
->Running
	-> initial stage of Executor
->Shutting down
	-> shutting down executor gracefully
	-> no new tasks are accepted
	-> previously submitted tasks are allowed to complete—including those that have not yet begun execution
->Terminated
	-> Requests the task to stop by sending an interrupt
	-> does not start any tasks that are queued but not begun
	

All rejected tasks are handled by RejectedExecutionHandler


class LifecycleWebServer {
	private static final int NTHREADS = 100;
	private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);

	public void start() throws IOException {
		ServerSocket socket = new ServerSocket(80);
		while (!exec.isShutdown()) {
			try {
				final Socket conn = socket.accept();
				exec.execute(new Runnable() {
					public void run() {
						handleRequest(conn);
					}
				});
			} catch (RejectedExecutionException e) {
				if (!exec.isShutdown())
					log("task submission rejected", e);
			}
		}
	}

	public void stop() {
		exec.shutdown();
	}

	void handleRequest(Socket connection) {
		Request req = readRequest(connection);
		if (isShutdownRequest(req))
			stop();
		else
			dispatchRequest(req);
	}
}


For Delayed and periodic tasks use  ScheduledThreadPoolExecutor.


**run() cannot return a value or throw checked exceptions
call() will return a value and anticipates that it might throw an exception

Future represents the lifecycle of a task and provides methods to test whether the task has 
completed or 
been cancelled, 
retrieve its result, and 
cancel the task

task lifecycle can only move forwards, not backwards
Once a task is completed, it stays in that state forever

It returns immediately or throws an Exception if the task has already completed, 
but if not it blocks until the task completes
If the task completes by throwing an exception, get rethrows it wrapped in an ExecutionException


public interface Callable<V> {
	V call() throws Exception;
}

public interface Future<V> {
	boolean cancel(boolean mayInterruptIfRunning);

	boolean isCancelled();

	boolean isDone();

	V get() throws InterruptedException, ExecutionException, CancellationException;

	V get(long timeout, TimeUnit unit)
			throws InterruptedException, ExecutionException, CancellationException, TimeoutException;
}


**
The exception handling code surrounding Future.get() deals with two possible problems: 
that the task encountered an Exception, or 
the thread calling get was interrupted before the results were available

If you have a list of tasks to execute asynchronously,
you can use submitAll() method and then poll for result of each future
Alternatively, you can use CompletionService

ExecutorCompletionService implements CompletionService


(Q) How using thread pool Executor is better than creating object of thread class
	only those number of threads are created that CPU can handle
	cpu reuses thread from pool for execution of new task
	shutdown hook is available
	RejectionExecutionHandler is available
	configuring size of thread pool is a separate concern from execution of tasks
(Q) Threadpool reuses threads already created ?
	yes, using worker queue
	already created thread which has no task to execute, picks another task from worker queue
	->runWorker()
		->getTask()
(Q) Why ThreadPoolExecutor$Worker has two fields : 
	Thread thread;			// thread.start()
	Runnable firstTask;		// firstTask.run()

========================Chapter 7========================

Killing a thread is a  Cooperative Approach
If we do not follow that approach, 
it can leave shared data structure in an inconsistent state.

Why we require cancellation
-user requested
-time limited activity
-errors
-shutdown

One cooperative mechanism is setting a “cancellation requested” flag 
that the task checks periodically; if it finds the flag set, the task terminates early.
cancelled flag must be volatile


@ThreadSafe
public class PrimeGenerator implements Runnable {
	@GuardedBy("this")
	private final List<BigInteger> primes = new ArrayList<BigInteger>();
	private volatile boolean cancelled;

	public void run() {
		BigInteger p = BigInteger.ONE;
		while (!cancelled) {
			p = p.nextProbablePrime();
			synchronized (this) {
				primes.add(p);
			}
		}
	}

	public void cancel() {
		cancelled = true;
	}

	public synchronized List<BigInteger> get() {
		return new ArrayList<BigInteger>(primes);
	}
}


(Q) How to handle cases of cancellation when code uses interrupted API like BlockingQueue

the task might never check the cancellation flag and therefore might never terminate

class BrokenPrimeProducer extends Thread {
	private final BlockingQueue<BigInteger> queue;
	private volatile boolean cancelled = false;

	BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {
		this.queue = queue;
	}

	public void run() {
		try {
			BigInteger p = BigInteger.ONE;
			while (!cancelled)
				queue.put(p = p.nextProbablePrime());
		} catch (InterruptedException consumed) {
		}
	}

	public void cancel() {
		cancelled = true;
	}
}

void consumePrimes() throws InterruptedException { 
	BlockingQueue<BigInteger> primes = ...; 
	BrokenPrimeProducer producer = new BrokenPrimeProducer(primes); 
	producer.start(); 
	try { 
		while (needMorePrimes()) 
			consume(primes.take()); 
	} finally { 
		producer.cancel(); 
	} 
}

Problem :
 The producer thread generates primes and places them on a blocking queue. 
 If the producer gets ahead of the consumer, the queue will fill up and put will block. 
 What happens if the consumer tries to cancel the producer task while it is blocked in put? 
 It can call cancel which will set the cancelled flag—but the producer will never check the flag
 because it will never emerge from the blocking put 
 (because the consumer has stopped retrieving primes from the queue). 
 
 
Each thread has a boolean interrupted status; interrupting a thread sets its interrupted status to true
Thread contains methods for interrupting a thread and querying the interrupted status of a thread
  
  
public class Thread { 
	public void interrupt() { ... } 
	public boolean isInterrupted() { ... } 
	public static boolean interrupted() { ... } 
	... 
}

1)->interrupt() method interrupts the target thread

2)->isInterrupted() returns the interrupted status of the target thread

3)->static interrupted() method clears the interrupted status of the current thread 
	and returns its previous value.
	this is the only way to clear the interrupted status.
	
 method (1) sets the interrupt status
 method (2) checks the interrupt status
 method (3) clears the interrupt status
  

Thread.sleep and Object.wait try to detect when a thread has been interrupted and return early.
They respond to interruption by clearing the interrupted status and 
throwing InterruptedException,indicating that the blocking operation completed early due to interruption


If a thread is interrupted when it is not blocked, its interrupted status is set, and 
it is up to the activity being cancelled to poll the interrupted status to detect interruption.
In this way interruption is “sticky”—if it doesn’t trigger an InterruptedException, 
evidence of interruption persists until someone deliberately clears the interrupted status


A good way to think about interruption is that it does not actually interrupt a running thread;
 it just requests that the thread interrupt itself at the next convenient opportunity.
 (These opportunities are called cancellation points.) 
 Some methods, such as wait, sleep, and join, take such requests seriously,
 throwing an exception when they receive an interrupt request or 
 encounter an already set interrupt status upon entry. 
 Well behaved methods may totally ignore such requests so long as they leave 
 the interruption request in place so that calling code can do something with it. 
 Poorly behaved methods swallow the interrupt request, 
 thus denying code further up the call stack the opportunity to act on it. 
 The static interrupted method should be used with caution, 
 because it clears the current thread’s interrupted status. 
 If you call interrupted and it returns true, 
 unless you are planning to swallow the interruption, 
 you should do something with it—either throw InterruptedException or 
 restore the interrupted status by calling interrupt again



class PrimeProducer extends Thread {
	private final BlockingQueue<BigInteger> queue;

	PrimeProducer(BlockingQueue<BigInteger> queue) {
		this.queue = queue;
	}

	public void run() {
		try {
			BigInteger p = BigInteger.ONE;
			while (!Thread.currentThread().isInterrupted())
				queue.put(p = p.nextProbablePrime());
		} catch (InterruptedException consumed) {
			/* Allow thread to exit */ }
	}

	public void cancel() {
		interrupt();
	}
}


Calling interrupt does not necessarily stop the target thread from doing what it is doing;
it merely delivers the message that interruption has been requested.



=============================================================================


==>Practice Programs :

public class Test {
	public static void main(String[] args) throws InterruptedException {

		Lock lock = new ReentrantLock();
		Thread t1 = new Myclass(1, lock);
		Thread t2 = new Myclass(2, lock);
		t1.start();
		t2.start();
		t2.interrupt();
	}
}

class Myclass extends Thread {

	private int x;
	private Lock lock;

	public Myclass(int x, Lock lock) {
		this.x = x;
		this.lock = lock;
	}

	public void run() {
		lock.lock();
		try {
			System.out.println("thread " + x + " " + Thread.currentThread().isInterrupted());
		} finally {
			System.out.println("finally started: " + x);
			lock.unlock();
		}
		System.out.println("Thread finished: " + x);
	}
}



//output
thread 1 false
finally started: 1
Thread finished: 1
thread 2 true
finally started: 2
Thread finished: 2


(Q) Diff b/w lock() and lockInterruptibly() ?

NOTE : When a thread is running while taking a lock, i.e. b/w lock() and unlock()
		and an interrupt is fired on that thread, 
		then only interrupt status is set for that thread
		
		calling interrupt() while waiting on lock() method 
		will not remove lock and will end up normal execution

		calling interrupt() while waiting on lockInterruptibly() method
		will throw InterruptedException and lock will be released
		No lock will be held for further execution
		
Note : calling unlock() without lock() causes  IllegalMonitorStateException

=================================================================

public class Test {
	public static void main(String[] args) throws InterruptedException {

		Lock lock = new ReentrantLock();
		Thread t1 = new Myclass(1, lock);
		Thread t2 = new Myclass(2, lock);
		t1.start();
		t2.start();
		t2.interrupt();
	}
}

class Myclass extends Thread {

	private int x;
	private Lock lock;

	public Myclass(int x, Lock lock) {
		this.x = x;
		this.lock = lock;
	}

	public void run() {
		try {
			lock.lockInterruptibly();
		} catch (InterruptedException e) {
			System.out.println(e);
		}
		try {
			System.out.println("Thread " + x + " " + Thread.currentThread().isInterrupted());
		} finally {
			System.out.println("finally started Thread : " + x);
			lock.unlock();
		}
		System.out.println("Thread : " + x + " finished");
	}
}


Note : calling unlock() without lock() causes  IllegalMonitorStateException

// output
Thread 1 false
finally started Thread : 1
Thread : 1 finished
java.lang.InterruptedException
Thread 2 false
finally started Thread : 2
Exception in thread "Thread-1" java.lang.IllegalMonitorStateException

=================================================================

public class Test {
	public static void main(String[] args) throws InterruptedException {

		Lock lock = new ReentrantLock();
		Thread t1 = new Myclass(1, lock);
		Thread t2 = new Myclass(2, lock);
		t1.start();
		t2.start();
		t2.interrupt();
	}
}

class Myclass extends Thread {

	private int x;
	private Lock lock;

	public Myclass(int x, Lock lock) {
		this.x = x;
		this.lock = lock;
	}

	public void run() {
		try {
			lock.lockInterruptibly();
			try {
				System.out.println("Thread " + x + " " + Thread.currentThread().isInterrupted());
			} finally {
				System.out.println("finally started: " + x);
				lock.unlock();
			}
			System.out.println("thread : " + x + " finished");
		} catch (InterruptedException e1) {
			System.out.println("Thread :"+x+" Interrupted before lock acquring, critical section not executed");
		}
	}
}


// Output :
Thread 1 false
finally started: 1
thread : 1 finished
Thread :2 Interrupted before lock acquring, critical section not executed


=================================================================

public class Test {
	public static void main(String[] args) throws InterruptedException {

		Lock lock = new ReentrantLock();
		Thread t1 = new Myclass(lock);
		Thread t2 = new Myclass(lock);
		t1.start();
		t2.start();
	}
}

class Myclass extends Thread {

	private Lock lock;

	public Myclass(Lock lock) {
		this.lock = lock;
	}

	public void run() {
		lock.lock();
	}
}


/**
t1 thread completes its execution but will never release lock
t2 thread will never get any chance to execute
JVM will be running for ever , as there is a non-deamon thread which is waiting for lock
**/



=================================================================

public class Test {
	public static void main(String[] args) throws InterruptedException {

		Lock lock = new ReentrantLock();
		Thread t1 = new Myclass(lock);
		t1.start();
	}
}

class Myclass extends Thread {

	private Lock lock;

	public Myclass(Lock lock) {
		this.lock = lock;
	}

	public void run() {
		lock.lock();
	}
}

/**
t1 thread completes its execution but will never release lock
JVM process will be over
**/


=================================================================

shutdownNow()  
	-> tries to Stop running thread with interrupt
	-> does not execute waiting threads in queue, 
		waiting threads are not cancelled, they have state = NEW
	
shutdown() 
	-> does not interrupt any thread
	-> executes all running threads and awaiting threads in queue
	
========================================================================

public class MyShutDownNow {

	public static void main(String args[]) throws InterruptedException {
		ExecutorService es = Executors.newFixedThreadPool(2);
		es.submit(new MyWorkerEx());
		es.submit(new MyWorkerEx());
		es.submit(new MyWorkerEx());
		es.submit(new MyWorkerEx());
		List<Runnable> runnables = es.shutdownNow();
		Thread.sleep(1000);
		System.out.println("awaiting task in the queue : " + runnables.size());
		for (Runnable runnable : runnables) {
			RunnableFuture<String> future = ((RunnableFuture<String>) runnable);
			System.out.println(runnable.getClass().getName() + " cancelled : " + future.isCancelled());
		}
	}
}

class MyWorkerEx implements Callable<String> {

	public String call() {
		System.out.println("started...");
		while (!Thread.currentThread().isInterrupted()) {
			System.out.println("running..." + Thread.currentThread().getName());
		}
		System.out.println("interrupt status : " + Thread.currentThread().isInterrupted());
		return "hello";
	}
}


=> Output : 

started...
started...
interrupt status : true
interrupt status : true
awaiting task in the queue : 2
java.util.concurrent.FutureTask cancelled : false
java.util.concurrent.FutureTask cancelled : false

========================================================================

(Q) if new task is submitted after shutdownNow() method ?

-> RejectedExecutionException will occur 

========================================================================

public class MyShutDown {

	public static void main(String args[]) throws InterruptedException {
		ExecutorService es = Executors.newFixedThreadPool(2);
		es.submit(new MyWorkerEx());
		es.submit(new MyWorkerEx());
		es.submit(new MyWorkerEx());
		es.submit(new MyWorkerEx());
		es.shutdown();
	}
}

class MyWorkerEx implements Callable<String> {

	public String call() {
		System.out.println("started...");
		if (!Thread.currentThread().isInterrupted()) {
			System.out.println("running..." + Thread.currentThread().getName());
		}
		System.out.println("interrupt status : " + Thread.currentThread().isInterrupted());
		return "hello";
	}
}


=> Output : 

started...
started...
running...pool-1-thread-1
running...pool-1-thread-2
interrupt status : false
interrupt status : false
started...
running...pool-1-thread-2
interrupt status : false
started...
running...pool-1-thread-1
interrupt status : false


========================================================================

(Q) When waiting task in queue is kept for more than threshold time
-> RejectedExecutionException occurs


public class MyThreadPoolEx {

	public static void main(String args[]) throws InterruptedException {
		BlockingQueue<Runnable> queue = new LinkedBlockingQueue<Runnable>(1);
		ExecutorService es = new ThreadPoolExecutor(1, 1, 0, TimeUnit.NANOSECONDS,queue);
		es.submit(new MyWorkerEx());
		es.submit(new MyWorkerEx());
		es.submit(new MyWorkerEx());
		es.shutdown();
	}
}

class MyWorkerEx implements Runnable {

	public void run() {
		System.out.println("started...");
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("Ended..");
	}
}



started...
Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@5c647e05 rejected from java.util.concurrent.ThreadPoolExecutor@33909752[Running, pool size = 1, active threads = 1, queued tasks = 1, completed tasks = 0]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.reject(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source)
	at java.util.concurrent.AbstractExecutorService.submit(Unknown Source)
	at com.akash.threadpool.MyThreadPoolEx.main(MyThreadPoolEx.java:16)
Ended..
started...
Ended..

========================================================


awaitTermination() is used to wait after shutdown() method is called


=============================================================

(Q) Diff bw submit() and invokeAll()

Option 1 :
	ExecutorService executorService = Executors.newFixedThreadPool(5);
	List<Future<String>> futures = new ArrayList<>();
	for(Callable callableItem: myCallableList){
		futures.add(executorService.submit(callableItem));
	}


Option 2 :
	ExecutorService executorService = Executors.newFixedThreadPool(5);
	List<Future<String>> futures = executorService.invokeAll(myCallableList));
	
In Option 2, you have to wait for completion of all submitted tasks to ExecutorService unlike in Option 1
